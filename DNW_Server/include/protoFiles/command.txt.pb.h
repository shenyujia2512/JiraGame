// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: command.txt

#ifndef PROTOBUF_command_2etxt__INCLUDED
#define PROTOBUF_command_2etxt__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "scene.txt.pb.h"
// @@protoc_insertion_point(includes)
namespace PBMessage {
class CMD_MoveToPoint;
class CMD_MoveToPointDefaultTypeInternal;
extern CMD_MoveToPointDefaultTypeInternal _CMD_MoveToPoint_default_instance_;
class CMD_ReleaseSkill;
class CMD_ReleaseSkillDefaultTypeInternal;
extern CMD_ReleaseSkillDefaultTypeInternal _CMD_ReleaseSkill_default_instance_;
class CreateRoleRequest;
class CreateRoleRequestDefaultTypeInternal;
extern CreateRoleRequestDefaultTypeInternal _CreateRoleRequest_default_instance_;
class CreateRoleReturn;
class CreateRoleReturnDefaultTypeInternal;
extern CreateRoleReturnDefaultTypeInternal _CreateRoleReturn_default_instance_;
class Disconnect;
class DisconnectDefaultTypeInternal;
extern DisconnectDefaultTypeInternal _Disconnect_default_instance_;
class GameMainRequest;
class GameMainRequestDefaultTypeInternal;
extern GameMainRequestDefaultTypeInternal _GameMainRequest_default_instance_;
class GameMainReturn;
class GameMainReturnDefaultTypeInternal;
extern GameMainReturnDefaultTypeInternal _GameMainReturn_default_instance_;
class HallInfo;
class HallInfoDefaultTypeInternal;
extern HallInfoDefaultTypeInternal _HallInfo_default_instance_;
class HallRequest;
class HallRequestDefaultTypeInternal;
extern HallRequestDefaultTypeInternal _HallRequest_default_instance_;
class HallReturn;
class HallReturnDefaultTypeInternal;
extern HallReturnDefaultTypeInternal _HallReturn_default_instance_;
class InviteInfo;
class InviteInfoDefaultTypeInternal;
extern InviteInfoDefaultTypeInternal _InviteInfo_default_instance_;
class KeepAliveMsg;
class KeepAliveMsgDefaultTypeInternal;
extern KeepAliveMsgDefaultTypeInternal _KeepAliveMsg_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginReturn;
class LoginReturnDefaultTypeInternal;
extern LoginReturnDefaultTypeInternal _LoginReturn_default_instance_;
class Packet;
class PacketDefaultTypeInternal;
extern PacketDefaultTypeInternal _Packet_default_instance_;
class PlayerInfo;
class PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class Position2D;
class Position2DDefaultTypeInternal;
extern Position2DDefaultTypeInternal _Position2D_default_instance_;
class Position3D;
class Position3DDefaultTypeInternal;
extern Position3DDefaultTypeInternal _Position3D_default_instance_;
class RegisterRequest;
class RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterReturn;
class RegisterReturnDefaultTypeInternal;
extern RegisterReturnDefaultTypeInternal _RegisterReturn_default_instance_;
class RoomInfo;
class RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class SelectRoleRequest;
class SelectRoleRequestDefaultTypeInternal;
extern SelectRoleRequestDefaultTypeInternal _SelectRoleRequest_default_instance_;
class SelectRoleReturn;
class SelectRoleReturnDefaultTypeInternal;
extern SelectRoleReturnDefaultTypeInternal _SelectRoleReturn_default_instance_;
class UnPacket;
class UnPacketDefaultTypeInternal;
extern UnPacketDefaultTypeInternal _UnPacket_default_instance_;
}  // namespace PBMessage

namespace PBMessage {

namespace protobuf_command_2etxt {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_command_2etxt

enum CommandID {
  ReleaseSkill = 1,
  MoveToPoint = 2
};
bool CommandID_IsValid(int value);
const CommandID CommandID_MIN = ReleaseSkill;
const CommandID CommandID_MAX = MoveToPoint;
const int CommandID_ARRAYSIZE = CommandID_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommandID_descriptor();
inline const ::std::string& CommandID_Name(CommandID value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommandID_descriptor(), value);
}
inline bool CommandID_Parse(
    const ::std::string& name, CommandID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandID>(
    CommandID_descriptor(), name, value);
}
enum CurScene {
  CS_None = 0,
  CS_Login = 1,
  CS_Register = 2,
  CS_CreateRole = 3,
  CS_SelectRole = 4,
  CS_WaitRoom = 5,
  CS_MainScene = 6,
  CS_KeepAlive = 7,
  CS_BreakLineRecon = 8
};
bool CurScene_IsValid(int value);
const CurScene CurScene_MIN = CS_None;
const CurScene CurScene_MAX = CS_BreakLineRecon;
const int CurScene_ARRAYSIZE = CurScene_MAX + 1;

const ::google::protobuf::EnumDescriptor* CurScene_descriptor();
inline const ::std::string& CurScene_Name(CurScene value) {
  return ::google::protobuf::internal::NameOfEnum(
    CurScene_descriptor(), value);
}
inline bool CurScene_Parse(
    const ::std::string& name, CurScene* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CurScene>(
    CurScene_descriptor(), name, value);
}
enum MessageType {
  IdInfo = 0,
  CreateInfo = 1,
  TextInfo = 2,
  MoveInfo = 3,
  DestroyInfo = 4,
  AsynInfo = 5
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = IdInfo;
const MessageType MessageType_MAX = AsynInfo;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum LoginReturnType {
  Fail = 0,
  ToCreateRole = 1,
  ToSelectRole = 2
};
bool LoginReturnType_IsValid(int value);
const LoginReturnType LoginReturnType_MIN = Fail;
const LoginReturnType LoginReturnType_MAX = ToSelectRole;
const int LoginReturnType_ARRAYSIZE = LoginReturnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginReturnType_descriptor();
inline const ::std::string& LoginReturnType_Name(LoginReturnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginReturnType_descriptor(), value);
}
inline bool LoginReturnType_Parse(
    const ::std::string& name, LoginReturnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginReturnType>(
    LoginReturnType_descriptor(), name, value);
}
enum RegisterReturnType {
  RT_Fail = 0,
  RT_Success = 1
};
bool RegisterReturnType_IsValid(int value);
const RegisterReturnType RegisterReturnType_MIN = RT_Fail;
const RegisterReturnType RegisterReturnType_MAX = RT_Success;
const int RegisterReturnType_ARRAYSIZE = RegisterReturnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegisterReturnType_descriptor();
inline const ::std::string& RegisterReturnType_Name(RegisterReturnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegisterReturnType_descriptor(), value);
}
inline bool RegisterReturnType_Parse(
    const ::std::string& name, RegisterReturnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegisterReturnType>(
    RegisterReturnType_descriptor(), name, value);
}
enum CreateRoleReturnType {
  CRT_Fail = 0,
  CRT_Success = 1
};
bool CreateRoleReturnType_IsValid(int value);
const CreateRoleReturnType CreateRoleReturnType_MIN = CRT_Fail;
const CreateRoleReturnType CreateRoleReturnType_MAX = CRT_Success;
const int CreateRoleReturnType_ARRAYSIZE = CreateRoleReturnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CreateRoleReturnType_descriptor();
inline const ::std::string& CreateRoleReturnType_Name(CreateRoleReturnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CreateRoleReturnType_descriptor(), value);
}
inline bool CreateRoleReturnType_Parse(
    const ::std::string& name, CreateRoleReturnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CreateRoleReturnType>(
    CreateRoleReturnType_descriptor(), name, value);
}
enum HallMsgType {
  HST_AutoMatch = 0,
  HST_CreateRoom = 1,
  HST_GetRoomList = 2,
  HST_JoinRoom = 3,
  HST_GameStart = 4,
  HST_WaitTimeout = 5,
  HST_LeaveRoom = 6,
  HST_CreateRoomFail = 7,
  HST_OnlineFriend = 8,
  HST_RequestTeam = 9,
  HST_JoinTeam = 10,
  HST_GameWaite = 11,
  HST_KeepAlive = 12
};
bool HallMsgType_IsValid(int value);
const HallMsgType HallMsgType_MIN = HST_AutoMatch;
const HallMsgType HallMsgType_MAX = HST_KeepAlive;
const int HallMsgType_ARRAYSIZE = HallMsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* HallMsgType_descriptor();
inline const ::std::string& HallMsgType_Name(HallMsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    HallMsgType_descriptor(), value);
}
inline bool HallMsgType_Parse(
    const ::std::string& name, HallMsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HallMsgType>(
    HallMsgType_descriptor(), name, value);
}
enum GameMainMsgType {
  GMT_KeepAlive = 0,
  GMT_RsyncAttr = 1,
  GMT_RsyncStatus = 2,
  GMT_GameOver = 3,
  GMT_BreakLine = 4
};
bool GameMainMsgType_IsValid(int value);
const GameMainMsgType GameMainMsgType_MIN = GMT_KeepAlive;
const GameMainMsgType GameMainMsgType_MAX = GMT_BreakLine;
const int GameMainMsgType_ARRAYSIZE = GameMainMsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameMainMsgType_descriptor();
inline const ::std::string& GameMainMsgType_Name(GameMainMsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameMainMsgType_descriptor(), value);
}
inline bool GameMainMsgType_Parse(
    const ::std::string& name, GameMainMsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameMainMsgType>(
    GameMainMsgType_descriptor(), name, value);
}
// ===================================================================

class CMD_ReleaseSkill : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.CMD_ReleaseSkill) */ {
 public:
  CMD_ReleaseSkill();
  virtual ~CMD_ReleaseSkill();

  CMD_ReleaseSkill(const CMD_ReleaseSkill& from);

  inline CMD_ReleaseSkill& operator=(const CMD_ReleaseSkill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMD_ReleaseSkill& default_instance();

  static inline const CMD_ReleaseSkill* internal_default_instance() {
    return reinterpret_cast<const CMD_ReleaseSkill*>(
               &_CMD_ReleaseSkill_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(CMD_ReleaseSkill* other);

  // implements Message ----------------------------------------------

  inline CMD_ReleaseSkill* New() const PROTOBUF_FINAL { return New(NULL); }

  CMD_ReleaseSkill* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMD_ReleaseSkill& from);
  void MergeFrom(const CMD_ReleaseSkill& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMD_ReleaseSkill* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMessage.Position3D mouseposition = 3;
  bool has_mouseposition() const;
  void clear_mouseposition();
  static const int kMousepositionFieldNumber = 3;
  const ::PBMessage::Position3D& mouseposition() const;
  ::PBMessage::Position3D* mutable_mouseposition();
  ::PBMessage::Position3D* release_mouseposition();
  void set_allocated_mouseposition(::PBMessage::Position3D* mouseposition);

  // required int32 roleId = 1;
  bool has_roleid() const;
  void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  ::google::protobuf::int32 roleid() const;
  void set_roleid(::google::protobuf::int32 value);

  // required int32 skillId = 2;
  bool has_skillid() const;
  void clear_skillid();
  static const int kSkillIdFieldNumber = 2;
  ::google::protobuf::int32 skillid() const;
  void set_skillid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBMessage.CMD_ReleaseSkill)
 private:
  void set_has_roleid();
  void clear_has_roleid();
  void set_has_skillid();
  void clear_has_skillid();
  void set_has_mouseposition();
  void clear_has_mouseposition();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::PBMessage::Position3D* mouseposition_;
  ::google::protobuf::int32 roleid_;
  ::google::protobuf::int32 skillid_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class CMD_MoveToPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.CMD_MoveToPoint) */ {
 public:
  CMD_MoveToPoint();
  virtual ~CMD_MoveToPoint();

  CMD_MoveToPoint(const CMD_MoveToPoint& from);

  inline CMD_MoveToPoint& operator=(const CMD_MoveToPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMD_MoveToPoint& default_instance();

  static inline const CMD_MoveToPoint* internal_default_instance() {
    return reinterpret_cast<const CMD_MoveToPoint*>(
               &_CMD_MoveToPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CMD_MoveToPoint* other);

  // implements Message ----------------------------------------------

  inline CMD_MoveToPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  CMD_MoveToPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMD_MoveToPoint& from);
  void MergeFrom(const CMD_MoveToPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMD_MoveToPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMessage.Position3D position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::PBMessage::Position3D& position() const;
  ::PBMessage::Position3D* mutable_position();
  ::PBMessage::Position3D* release_position();
  void set_allocated_position(::PBMessage::Position3D* position);

  // required .PBMessage.Position3D direction = 3;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 3;
  const ::PBMessage::Position3D& direction() const;
  ::PBMessage::Position3D* mutable_direction();
  ::PBMessage::Position3D* release_direction();
  void set_allocated_direction(::PBMessage::Position3D* direction);

  // required .PBMessage.Position3D destination = 4;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 4;
  const ::PBMessage::Position3D& destination() const;
  ::PBMessage::Position3D* mutable_destination();
  ::PBMessage::Position3D* release_destination();
  void set_allocated_destination(::PBMessage::Position3D* destination);

  // required int32 roleId = 1;
  bool has_roleid() const;
  void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  ::google::protobuf::int32 roleid() const;
  void set_roleid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBMessage.CMD_MoveToPoint)
 private:
  void set_has_roleid();
  void clear_has_roleid();
  void set_has_position();
  void clear_has_position();
  void set_has_direction();
  void clear_has_direction();
  void set_has_destination();
  void clear_has_destination();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::PBMessage::Position3D* position_;
  ::PBMessage::Position3D* direction_;
  ::PBMessage::Position3D* destination_;
  ::google::protobuf::int32 roleid_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class Disconnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.Disconnect) */ {
 public:
  Disconnect();
  virtual ~Disconnect();

  Disconnect(const Disconnect& from);

  inline Disconnect& operator=(const Disconnect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Disconnect& default_instance();

  static inline const Disconnect* internal_default_instance() {
    return reinterpret_cast<const Disconnect*>(
               &_Disconnect_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Disconnect* other);

  // implements Message ----------------------------------------------

  inline Disconnect* New() const PROTOBUF_FINAL { return New(NULL); }

  Disconnect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Disconnect& from);
  void MergeFrom(const Disconnect& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Disconnect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 roleId = 1;
  bool has_roleid() const;
  void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  ::google::protobuf::int32 roleid() const;
  void set_roleid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBMessage.Disconnect)
 private:
  void set_has_roleid();
  void clear_has_roleid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 roleid_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class KeepAliveMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.KeepAliveMsg) */ {
 public:
  KeepAliveMsg();
  virtual ~KeepAliveMsg();

  KeepAliveMsg(const KeepAliveMsg& from);

  inline KeepAliveMsg& operator=(const KeepAliveMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeepAliveMsg& default_instance();

  static inline const KeepAliveMsg* internal_default_instance() {
    return reinterpret_cast<const KeepAliveMsg*>(
               &_KeepAliveMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(KeepAliveMsg* other);

  // implements Message ----------------------------------------------

  inline KeepAliveMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  KeepAliveMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeepAliveMsg& from);
  void MergeFrom(const KeepAliveMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeepAliveMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMessage.CurScene curScene = 1;
  bool has_curscene() const;
  void clear_curscene();
  static const int kCurSceneFieldNumber = 1;
  ::PBMessage::CurScene curscene() const;
  void set_curscene(::PBMessage::CurScene value);

  // @@protoc_insertion_point(class_scope:PBMessage.KeepAliveMsg)
 private:
  void set_has_curscene();
  void clear_has_curscene();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int curscene_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userName = 1;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required string passWord = 2;
  bool has_password() const;
  void clear_password();
  static const int kPassWordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:PBMessage.LoginRequest)
 private:
  void set_has_username();
  void clear_has_username();
  void set_has_password();
  void clear_has_password();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class LoginReturn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.LoginReturn) */ {
 public:
  LoginReturn();
  virtual ~LoginReturn();

  LoginReturn(const LoginReturn& from);

  inline LoginReturn& operator=(const LoginReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReturn& default_instance();

  static inline const LoginReturn* internal_default_instance() {
    return reinterpret_cast<const LoginReturn*>(
               &_LoginReturn_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(LoginReturn* other);

  // implements Message ----------------------------------------------

  inline LoginReturn* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginReturn* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginReturn& from);
  void MergeFrom(const LoginReturn& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginReturn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PBMessage.PlayerInfo playerInfo = 3;
  int playerinfo_size() const;
  void clear_playerinfo();
  static const int kPlayerInfoFieldNumber = 3;
  const ::PBMessage::PlayerInfo& playerinfo(int index) const;
  ::PBMessage::PlayerInfo* mutable_playerinfo(int index);
  ::PBMessage::PlayerInfo* add_playerinfo();
  ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >*
      mutable_playerinfo();
  const ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >&
      playerinfo() const;

  // required string sessionID = 1;
  bool has_sessionid() const;
  void clear_sessionid();
  static const int kSessionIDFieldNumber = 1;
  const ::std::string& sessionid() const;
  void set_sessionid(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionid(::std::string&& value);
  #endif
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  ::std::string* mutable_sessionid();
  ::std::string* release_sessionid();
  void set_allocated_sessionid(::std::string* sessionid);

  // required .PBMessage.LoginReturnType returnType = 2;
  bool has_returntype() const;
  void clear_returntype();
  static const int kReturnTypeFieldNumber = 2;
  ::PBMessage::LoginReturnType returntype() const;
  void set_returntype(::PBMessage::LoginReturnType value);

  // @@protoc_insertion_point(class_scope:PBMessage.LoginReturn)
 private:
  void set_has_sessionid();
  void clear_has_sessionid();
  void set_has_returntype();
  void clear_has_returntype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo > playerinfo_;
  ::google::protobuf::internal::ArenaStringPtr sessionid_;
  int returntype_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class RegisterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.RegisterRequest) */ {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequest& default_instance();

  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(RegisterRequest* other);

  // implements Message ----------------------------------------------

  inline RegisterRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RegisterRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegisterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userName = 1;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required string passWord = 2;
  bool has_password() const;
  void clear_password();
  static const int kPassWordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:PBMessage.RegisterRequest)
 private:
  void set_has_username();
  void clear_has_username();
  void set_has_password();
  void clear_has_password();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class RegisterReturn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.RegisterReturn) */ {
 public:
  RegisterReturn();
  virtual ~RegisterReturn();

  RegisterReturn(const RegisterReturn& from);

  inline RegisterReturn& operator=(const RegisterReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterReturn& default_instance();

  static inline const RegisterReturn* internal_default_instance() {
    return reinterpret_cast<const RegisterReturn*>(
               &_RegisterReturn_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(RegisterReturn* other);

  // implements Message ----------------------------------------------

  inline RegisterReturn* New() const PROTOBUF_FINAL { return New(NULL); }

  RegisterReturn* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegisterReturn& from);
  void MergeFrom(const RegisterReturn& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegisterReturn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PBMessage.RegisterReturnType returnType = 1;
  bool has_returntype() const;
  void clear_returntype();
  static const int kReturnTypeFieldNumber = 1;
  ::PBMessage::RegisterReturnType returntype() const;
  void set_returntype(::PBMessage::RegisterReturnType value);

  // @@protoc_insertion_point(class_scope:PBMessage.RegisterReturn)
 private:
  void set_has_returntype();
  void clear_has_returntype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int returntype_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class CreateRoleRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.CreateRoleRequest) */ {
 public:
  CreateRoleRequest();
  virtual ~CreateRoleRequest();

  CreateRoleRequest(const CreateRoleRequest& from);

  inline CreateRoleRequest& operator=(const CreateRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoleRequest& default_instance();

  static inline const CreateRoleRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRoleRequest*>(
               &_CreateRoleRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(CreateRoleRequest* other);

  // implements Message ----------------------------------------------

  inline CreateRoleRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRoleRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRoleRequest& from);
  void MergeFrom(const CreateRoleRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRoleRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sessionID = 1;
  bool has_sessionid() const;
  void clear_sessionid();
  static const int kSessionIDFieldNumber = 1;
  const ::std::string& sessionid() const;
  void set_sessionid(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionid(::std::string&& value);
  #endif
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  ::std::string* mutable_sessionid();
  ::std::string* release_sessionid();
  void set_allocated_sessionid(::std::string* sessionid);

  // required .PBMessage.PlayerInfo playerInfo = 2;
  bool has_playerinfo() const;
  void clear_playerinfo();
  static const int kPlayerInfoFieldNumber = 2;
  const ::PBMessage::PlayerInfo& playerinfo() const;
  ::PBMessage::PlayerInfo* mutable_playerinfo();
  ::PBMessage::PlayerInfo* release_playerinfo();
  void set_allocated_playerinfo(::PBMessage::PlayerInfo* playerinfo);

  // @@protoc_insertion_point(class_scope:PBMessage.CreateRoleRequest)
 private:
  void set_has_sessionid();
  void clear_has_sessionid();
  void set_has_playerinfo();
  void clear_has_playerinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sessionid_;
  ::PBMessage::PlayerInfo* playerinfo_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class CreateRoleReturn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.CreateRoleReturn) */ {
 public:
  CreateRoleReturn();
  virtual ~CreateRoleReturn();

  CreateRoleReturn(const CreateRoleReturn& from);

  inline CreateRoleReturn& operator=(const CreateRoleReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoleReturn& default_instance();

  static inline const CreateRoleReturn* internal_default_instance() {
    return reinterpret_cast<const CreateRoleReturn*>(
               &_CreateRoleReturn_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(CreateRoleReturn* other);

  // implements Message ----------------------------------------------

  inline CreateRoleReturn* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRoleReturn* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRoleReturn& from);
  void MergeFrom(const CreateRoleReturn& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRoleReturn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PBMessage.PlayerInfo playerInfo = 2;
  int playerinfo_size() const;
  void clear_playerinfo();
  static const int kPlayerInfoFieldNumber = 2;
  const ::PBMessage::PlayerInfo& playerinfo(int index) const;
  ::PBMessage::PlayerInfo* mutable_playerinfo(int index);
  ::PBMessage::PlayerInfo* add_playerinfo();
  ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >*
      mutable_playerinfo();
  const ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >&
      playerinfo() const;

  // required .PBMessage.CreateRoleReturnType returnType = 1;
  bool has_returntype() const;
  void clear_returntype();
  static const int kReturnTypeFieldNumber = 1;
  ::PBMessage::CreateRoleReturnType returntype() const;
  void set_returntype(::PBMessage::CreateRoleReturnType value);

  // @@protoc_insertion_point(class_scope:PBMessage.CreateRoleReturn)
 private:
  void set_has_returntype();
  void clear_has_returntype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo > playerinfo_;
  int returntype_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class SelectRoleRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.SelectRoleRequest) */ {
 public:
  SelectRoleRequest();
  virtual ~SelectRoleRequest();

  SelectRoleRequest(const SelectRoleRequest& from);

  inline SelectRoleRequest& operator=(const SelectRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectRoleRequest& default_instance();

  static inline const SelectRoleRequest* internal_default_instance() {
    return reinterpret_cast<const SelectRoleRequest*>(
               &_SelectRoleRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(SelectRoleRequest* other);

  // implements Message ----------------------------------------------

  inline SelectRoleRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectRoleRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectRoleRequest& from);
  void MergeFrom(const SelectRoleRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectRoleRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sessionID = 1;
  bool has_sessionid() const;
  void clear_sessionid();
  static const int kSessionIDFieldNumber = 1;
  const ::std::string& sessionid() const;
  void set_sessionid(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionid(::std::string&& value);
  #endif
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  ::std::string* mutable_sessionid();
  ::std::string* release_sessionid();
  void set_allocated_sessionid(::std::string* sessionid);

  // required int32 roleType = 2;
  bool has_roletype() const;
  void clear_roletype();
  static const int kRoleTypeFieldNumber = 2;
  ::google::protobuf::int32 roletype() const;
  void set_roletype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBMessage.SelectRoleRequest)
 private:
  void set_has_sessionid();
  void clear_has_sessionid();
  void set_has_roletype();
  void clear_has_roletype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sessionid_;
  ::google::protobuf::int32 roletype_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class SelectRoleReturn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.SelectRoleReturn) */ {
 public:
  SelectRoleReturn();
  virtual ~SelectRoleReturn();

  SelectRoleReturn(const SelectRoleReturn& from);

  inline SelectRoleReturn& operator=(const SelectRoleReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectRoleReturn& default_instance();

  static inline const SelectRoleReturn* internal_default_instance() {
    return reinterpret_cast<const SelectRoleReturn*>(
               &_SelectRoleReturn_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(SelectRoleReturn* other);

  // implements Message ----------------------------------------------

  inline SelectRoleReturn* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectRoleReturn* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectRoleReturn& from);
  void MergeFrom(const SelectRoleReturn& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectRoleReturn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBMessage.SelectRoleReturn)
 private:
  void set_has_userid();
  void clear_has_userid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class HallRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.HallRequest) */ {
 public:
  HallRequest();
  virtual ~HallRequest();

  HallRequest(const HallRequest& from);

  inline HallRequest& operator=(const HallRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HallRequest& default_instance();

  static inline const HallRequest* internal_default_instance() {
    return reinterpret_cast<const HallRequest*>(
               &_HallRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(HallRequest* other);

  // implements Message ----------------------------------------------

  inline HallRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  HallRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HallRequest& from);
  void MergeFrom(const HallRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HallRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sessionID = 1;
  bool has_sessionid() const;
  void clear_sessionid();
  static const int kSessionIDFieldNumber = 1;
  const ::std::string& sessionid() const;
  void set_sessionid(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionid(::std::string&& value);
  #endif
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  ::std::string* mutable_sessionid();
  ::std::string* release_sessionid();
  void set_allocated_sessionid(::std::string* sessionid);

  // optional string roomName = 3;
  bool has_roomname() const;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 3;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // optional .PBMessage.InviteInfo inviteInfo = 5;
  bool has_inviteinfo() const;
  void clear_inviteinfo();
  static const int kInviteInfoFieldNumber = 5;
  const ::PBMessage::InviteInfo& inviteinfo() const;
  ::PBMessage::InviteInfo* mutable_inviteinfo();
  ::PBMessage::InviteInfo* release_inviteinfo();
  void set_allocated_inviteinfo(::PBMessage::InviteInfo* inviteinfo);

  // required .PBMessage.HallMsgType MsgType = 2;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgTypeFieldNumber = 2;
  ::PBMessage::HallMsgType msgtype() const;
  void set_msgtype(::PBMessage::HallMsgType value);

  // optional int32 userId = 4;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 4;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBMessage.HallRequest)
 private:
  void set_has_sessionid();
  void clear_has_sessionid();
  void set_has_msgtype();
  void clear_has_msgtype();
  void set_has_roomname();
  void clear_has_roomname();
  void set_has_userid();
  void clear_has_userid();
  void set_has_inviteinfo();
  void clear_has_inviteinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sessionid_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::PBMessage::InviteInfo* inviteinfo_;
  int msgtype_;
  ::google::protobuf::int32 userid_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class HallReturn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.HallReturn) */ {
 public:
  HallReturn();
  virtual ~HallReturn();

  HallReturn(const HallReturn& from);

  inline HallReturn& operator=(const HallReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HallReturn& default_instance();

  static inline const HallReturn* internal_default_instance() {
    return reinterpret_cast<const HallReturn*>(
               &_HallReturn_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(HallReturn* other);

  // implements Message ----------------------------------------------

  inline HallReturn* New() const PROTOBUF_FINAL { return New(NULL); }

  HallReturn* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HallReturn& from);
  void MergeFrom(const HallReturn& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HallReturn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PBMessage.PlayerInfo friendList = 5;
  int friendlist_size() const;
  void clear_friendlist();
  static const int kFriendListFieldNumber = 5;
  const ::PBMessage::PlayerInfo& friendlist(int index) const;
  ::PBMessage::PlayerInfo* mutable_friendlist(int index);
  ::PBMessage::PlayerInfo* add_friendlist();
  ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >*
      mutable_friendlist();
  const ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >&
      friendlist() const;

  // optional string roomName = 3;
  bool has_roomname() const;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 3;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // optional .PBMessage.HallInfo hallInfo = 1;
  bool has_hallinfo() const;
  void clear_hallinfo();
  static const int kHallInfoFieldNumber = 1;
  const ::PBMessage::HallInfo& hallinfo() const;
  ::PBMessage::HallInfo* mutable_hallinfo();
  ::PBMessage::HallInfo* release_hallinfo();
  void set_allocated_hallinfo(::PBMessage::HallInfo* hallinfo);

  // optional .PBMessage.InviteInfo inviteInfo = 6;
  bool has_inviteinfo() const;
  void clear_inviteinfo();
  static const int kInviteInfoFieldNumber = 6;
  const ::PBMessage::InviteInfo& inviteinfo() const;
  ::PBMessage::InviteInfo* mutable_inviteinfo();
  ::PBMessage::InviteInfo* release_inviteinfo();
  void set_allocated_inviteinfo(::PBMessage::InviteInfo* inviteinfo);

  // optional .PBMessage.HallMsgType MsgType = 2;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgTypeFieldNumber = 2;
  ::PBMessage::HallMsgType msgtype() const;
  void set_msgtype(::PBMessage::HallMsgType value);

  // optional int32 roomID = 4;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIDFieldNumber = 4;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PBMessage.HallReturn)
 private:
  void set_has_hallinfo();
  void clear_has_hallinfo();
  void set_has_msgtype();
  void clear_has_msgtype();
  void set_has_roomname();
  void clear_has_roomname();
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_inviteinfo();
  void clear_has_inviteinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo > friendlist_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::PBMessage::HallInfo* hallinfo_;
  ::PBMessage::InviteInfo* inviteinfo_;
  int msgtype_;
  ::google::protobuf::int32 roomid_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class GameMainRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.GameMainRequest) */ {
 public:
  GameMainRequest();
  virtual ~GameMainRequest();

  GameMainRequest(const GameMainRequest& from);

  inline GameMainRequest& operator=(const GameMainRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMainRequest& default_instance();

  static inline const GameMainRequest* internal_default_instance() {
    return reinterpret_cast<const GameMainRequest*>(
               &_GameMainRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(GameMainRequest* other);

  // implements Message ----------------------------------------------

  inline GameMainRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GameMainRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GameMainRequest& from);
  void MergeFrom(const GameMainRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GameMainRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sessionID = 1;
  bool has_sessionid() const;
  void clear_sessionid();
  static const int kSessionIDFieldNumber = 1;
  const ::std::string& sessionid() const;
  void set_sessionid(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionid(::std::string&& value);
  #endif
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  ::std::string* mutable_sessionid();
  ::std::string* release_sessionid();
  void set_allocated_sessionid(::std::string* sessionid);

  // optional .PBMessage.PlayerInfo playerInfo = 3;
  bool has_playerinfo() const;
  void clear_playerinfo();
  static const int kPlayerInfoFieldNumber = 3;
  const ::PBMessage::PlayerInfo& playerinfo() const;
  ::PBMessage::PlayerInfo* mutable_playerinfo();
  ::PBMessage::PlayerInfo* release_playerinfo();
  void set_allocated_playerinfo(::PBMessage::PlayerInfo* playerinfo);

  // required .PBMessage.GameMainMsgType msgType = 2;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgTypeFieldNumber = 2;
  ::PBMessage::GameMainMsgType msgtype() const;
  void set_msgtype(::PBMessage::GameMainMsgType value);

  // @@protoc_insertion_point(class_scope:PBMessage.GameMainRequest)
 private:
  void set_has_sessionid();
  void clear_has_sessionid();
  void set_has_msgtype();
  void clear_has_msgtype();
  void set_has_playerinfo();
  void clear_has_playerinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sessionid_;
  ::PBMessage::PlayerInfo* playerinfo_;
  int msgtype_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class GameMainReturn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.GameMainReturn) */ {
 public:
  GameMainReturn();
  virtual ~GameMainReturn();

  GameMainReturn(const GameMainReturn& from);

  inline GameMainReturn& operator=(const GameMainReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMainReturn& default_instance();

  static inline const GameMainReturn* internal_default_instance() {
    return reinterpret_cast<const GameMainReturn*>(
               &_GameMainReturn_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(GameMainReturn* other);

  // implements Message ----------------------------------------------

  inline GameMainReturn* New() const PROTOBUF_FINAL { return New(NULL); }

  GameMainReturn* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GameMainReturn& from);
  void MergeFrom(const GameMainReturn& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GameMainReturn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PBMessage.PlayerInfo friendList = 2;
  int friendlist_size() const;
  void clear_friendlist();
  static const int kFriendListFieldNumber = 2;
  const ::PBMessage::PlayerInfo& friendlist(int index) const;
  ::PBMessage::PlayerInfo* mutable_friendlist(int index);
  ::PBMessage::PlayerInfo* add_friendlist();
  ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >*
      mutable_friendlist();
  const ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >&
      friendlist() const;

  // required .PBMessage.GameMainMsgType msgType = 1;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgTypeFieldNumber = 1;
  ::PBMessage::GameMainMsgType msgtype() const;
  void set_msgtype(::PBMessage::GameMainMsgType value);

  // @@protoc_insertion_point(class_scope:PBMessage.GameMainReturn)
 private:
  void set_has_msgtype();
  void clear_has_msgtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo > friendlist_;
  int msgtype_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class Packet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.Packet) */ {
 public:
  Packet();
  virtual ~Packet();

  Packet(const Packet& from);

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet& default_instance();

  static inline const Packet* internal_default_instance() {
    return reinterpret_cast<const Packet*>(
               &_Packet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(Packet* other);

  // implements Message ----------------------------------------------

  inline Packet* New() const PROTOBUF_FINAL { return New(NULL); }

  Packet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Packet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PBMessage.LoginRequest loginRequest = 3;
  bool has_loginrequest() const;
  void clear_loginrequest();
  static const int kLoginRequestFieldNumber = 3;
  const ::PBMessage::LoginRequest& loginrequest() const;
  ::PBMessage::LoginRequest* mutable_loginrequest();
  ::PBMessage::LoginRequest* release_loginrequest();
  void set_allocated_loginrequest(::PBMessage::LoginRequest* loginrequest);

  // optional .PBMessage.LoginReturn loginReturn = 4;
  bool has_loginreturn() const;
  void clear_loginreturn();
  static const int kLoginReturnFieldNumber = 4;
  const ::PBMessage::LoginReturn& loginreturn() const;
  ::PBMessage::LoginReturn* mutable_loginreturn();
  ::PBMessage::LoginReturn* release_loginreturn();
  void set_allocated_loginreturn(::PBMessage::LoginReturn* loginreturn);

  // optional .PBMessage.RegisterRequest registerRequest = 5;
  bool has_registerrequest() const;
  void clear_registerrequest();
  static const int kRegisterRequestFieldNumber = 5;
  const ::PBMessage::RegisterRequest& registerrequest() const;
  ::PBMessage::RegisterRequest* mutable_registerrequest();
  ::PBMessage::RegisterRequest* release_registerrequest();
  void set_allocated_registerrequest(::PBMessage::RegisterRequest* registerrequest);

  // optional .PBMessage.RegisterReturn registerReturn = 6;
  bool has_registerreturn() const;
  void clear_registerreturn();
  static const int kRegisterReturnFieldNumber = 6;
  const ::PBMessage::RegisterReturn& registerreturn() const;
  ::PBMessage::RegisterReturn* mutable_registerreturn();
  ::PBMessage::RegisterReturn* release_registerreturn();
  void set_allocated_registerreturn(::PBMessage::RegisterReturn* registerreturn);

  // optional .PBMessage.CreateRoleRequest createRoleRequest = 7;
  bool has_createrolerequest() const;
  void clear_createrolerequest();
  static const int kCreateRoleRequestFieldNumber = 7;
  const ::PBMessage::CreateRoleRequest& createrolerequest() const;
  ::PBMessage::CreateRoleRequest* mutable_createrolerequest();
  ::PBMessage::CreateRoleRequest* release_createrolerequest();
  void set_allocated_createrolerequest(::PBMessage::CreateRoleRequest* createrolerequest);

  // optional .PBMessage.CreateRoleReturn createRoleReturn = 8;
  bool has_createrolereturn() const;
  void clear_createrolereturn();
  static const int kCreateRoleReturnFieldNumber = 8;
  const ::PBMessage::CreateRoleReturn& createrolereturn() const;
  ::PBMessage::CreateRoleReturn* mutable_createrolereturn();
  ::PBMessage::CreateRoleReturn* release_createrolereturn();
  void set_allocated_createrolereturn(::PBMessage::CreateRoleReturn* createrolereturn);

  // optional .PBMessage.SelectRoleRequest selectRoleRequest = 9;
  bool has_selectrolerequest() const;
  void clear_selectrolerequest();
  static const int kSelectRoleRequestFieldNumber = 9;
  const ::PBMessage::SelectRoleRequest& selectrolerequest() const;
  ::PBMessage::SelectRoleRequest* mutable_selectrolerequest();
  ::PBMessage::SelectRoleRequest* release_selectrolerequest();
  void set_allocated_selectrolerequest(::PBMessage::SelectRoleRequest* selectrolerequest);

  // optional .PBMessage.SelectRoleReturn selectRoleReturn = 10;
  bool has_selectrolereturn() const;
  void clear_selectrolereturn();
  static const int kSelectRoleReturnFieldNumber = 10;
  const ::PBMessage::SelectRoleReturn& selectrolereturn() const;
  ::PBMessage::SelectRoleReturn* mutable_selectrolereturn();
  ::PBMessage::SelectRoleReturn* release_selectrolereturn();
  void set_allocated_selectrolereturn(::PBMessage::SelectRoleReturn* selectrolereturn);

  // optional .PBMessage.HallRequest hallRequest = 11;
  bool has_hallrequest() const;
  void clear_hallrequest();
  static const int kHallRequestFieldNumber = 11;
  const ::PBMessage::HallRequest& hallrequest() const;
  ::PBMessage::HallRequest* mutable_hallrequest();
  ::PBMessage::HallRequest* release_hallrequest();
  void set_allocated_hallrequest(::PBMessage::HallRequest* hallrequest);

  // optional .PBMessage.HallReturn hallReturn = 12;
  bool has_hallreturn() const;
  void clear_hallreturn();
  static const int kHallReturnFieldNumber = 12;
  const ::PBMessage::HallReturn& hallreturn() const;
  ::PBMessage::HallReturn* mutable_hallreturn();
  ::PBMessage::HallReturn* release_hallreturn();
  void set_allocated_hallreturn(::PBMessage::HallReturn* hallreturn);

  // optional .PBMessage.GameMainRequest gameMainRequest = 13;
  bool has_gamemainrequest() const;
  void clear_gamemainrequest();
  static const int kGameMainRequestFieldNumber = 13;
  const ::PBMessage::GameMainRequest& gamemainrequest() const;
  ::PBMessage::GameMainRequest* mutable_gamemainrequest();
  ::PBMessage::GameMainRequest* release_gamemainrequest();
  void set_allocated_gamemainrequest(::PBMessage::GameMainRequest* gamemainrequest);

  // optional .PBMessage.GameMainReturn gameMainReturn = 14;
  bool has_gamemainreturn() const;
  void clear_gamemainreturn();
  static const int kGameMainReturnFieldNumber = 14;
  const ::PBMessage::GameMainReturn& gamemainreturn() const;
  ::PBMessage::GameMainReturn* mutable_gamemainreturn();
  ::PBMessage::GameMainReturn* release_gamemainreturn();
  void set_allocated_gamemainreturn(::PBMessage::GameMainReturn* gamemainreturn);

  // optional .PBMessage.KeepAliveMsg keepAlive = 15;
  bool has_keepalive() const;
  void clear_keepalive();
  static const int kKeepAliveFieldNumber = 15;
  const ::PBMessage::KeepAliveMsg& keepalive() const;
  ::PBMessage::KeepAliveMsg* mutable_keepalive();
  ::PBMessage::KeepAliveMsg* release_keepalive();
  void set_allocated_keepalive(::PBMessage::KeepAliveMsg* keepalive);

  // required .PBMessage.CurScene curScene = 1;
  bool has_curscene() const;
  void clear_curscene();
  static const int kCurSceneFieldNumber = 1;
  ::PBMessage::CurScene curscene() const;
  void set_curscene(::PBMessage::CurScene value);

  // optional .PBMessage.MessageType msgType = 2;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgTypeFieldNumber = 2;
  ::PBMessage::MessageType msgtype() const;
  void set_msgtype(::PBMessage::MessageType value);

  // @@protoc_insertion_point(class_scope:PBMessage.Packet)
 private:
  void set_has_curscene();
  void clear_has_curscene();
  void set_has_msgtype();
  void clear_has_msgtype();
  void set_has_loginrequest();
  void clear_has_loginrequest();
  void set_has_loginreturn();
  void clear_has_loginreturn();
  void set_has_registerrequest();
  void clear_has_registerrequest();
  void set_has_registerreturn();
  void clear_has_registerreturn();
  void set_has_createrolerequest();
  void clear_has_createrolerequest();
  void set_has_createrolereturn();
  void clear_has_createrolereturn();
  void set_has_selectrolerequest();
  void clear_has_selectrolerequest();
  void set_has_selectrolereturn();
  void clear_has_selectrolereturn();
  void set_has_hallrequest();
  void clear_has_hallrequest();
  void set_has_hallreturn();
  void clear_has_hallreturn();
  void set_has_gamemainrequest();
  void clear_has_gamemainrequest();
  void set_has_gamemainreturn();
  void clear_has_gamemainreturn();
  void set_has_keepalive();
  void clear_has_keepalive();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::PBMessage::LoginRequest* loginrequest_;
  ::PBMessage::LoginReturn* loginreturn_;
  ::PBMessage::RegisterRequest* registerrequest_;
  ::PBMessage::RegisterReturn* registerreturn_;
  ::PBMessage::CreateRoleRequest* createrolerequest_;
  ::PBMessage::CreateRoleReturn* createrolereturn_;
  ::PBMessage::SelectRoleRequest* selectrolerequest_;
  ::PBMessage::SelectRoleReturn* selectrolereturn_;
  ::PBMessage::HallRequest* hallrequest_;
  ::PBMessage::HallReturn* hallreturn_;
  ::PBMessage::GameMainRequest* gamemainrequest_;
  ::PBMessage::GameMainReturn* gamemainreturn_;
  ::PBMessage::KeepAliveMsg* keepalive_;
  int curscene_;
  int msgtype_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// -------------------------------------------------------------------

class UnPacket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PBMessage.UnPacket) */ {
 public:
  UnPacket();
  virtual ~UnPacket();

  UnPacket(const UnPacket& from);

  inline UnPacket& operator=(const UnPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnPacket& default_instance();

  static inline const UnPacket* internal_default_instance() {
    return reinterpret_cast<const UnPacket*>(
               &_UnPacket_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(UnPacket* other);

  // implements Message ----------------------------------------------

  inline UnPacket* New() const PROTOBUF_FINAL { return New(NULL); }

  UnPacket* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnPacket& from);
  void MergeFrom(const UnPacket& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnPacket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PBMessage.LoginRequest loginRequest = 3;
  bool has_loginrequest() const;
  void clear_loginrequest();
  static const int kLoginRequestFieldNumber = 3;
  const ::PBMessage::LoginRequest& loginrequest() const;
  ::PBMessage::LoginRequest* mutable_loginrequest();
  ::PBMessage::LoginRequest* release_loginrequest();
  void set_allocated_loginrequest(::PBMessage::LoginRequest* loginrequest);

  // optional .PBMessage.LoginReturn loginReturn = 4;
  bool has_loginreturn() const;
  void clear_loginreturn();
  static const int kLoginReturnFieldNumber = 4;
  const ::PBMessage::LoginReturn& loginreturn() const;
  ::PBMessage::LoginReturn* mutable_loginreturn();
  ::PBMessage::LoginReturn* release_loginreturn();
  void set_allocated_loginreturn(::PBMessage::LoginReturn* loginreturn);

  // optional .PBMessage.RegisterRequest registerRequest = 5;
  bool has_registerrequest() const;
  void clear_registerrequest();
  static const int kRegisterRequestFieldNumber = 5;
  const ::PBMessage::RegisterRequest& registerrequest() const;
  ::PBMessage::RegisterRequest* mutable_registerrequest();
  ::PBMessage::RegisterRequest* release_registerrequest();
  void set_allocated_registerrequest(::PBMessage::RegisterRequest* registerrequest);

  // optional .PBMessage.RegisterReturn registerReturn = 6;
  bool has_registerreturn() const;
  void clear_registerreturn();
  static const int kRegisterReturnFieldNumber = 6;
  const ::PBMessage::RegisterReturn& registerreturn() const;
  ::PBMessage::RegisterReturn* mutable_registerreturn();
  ::PBMessage::RegisterReturn* release_registerreturn();
  void set_allocated_registerreturn(::PBMessage::RegisterReturn* registerreturn);

  // optional .PBMessage.CreateRoleRequest createRoleRequest = 7;
  bool has_createrolerequest() const;
  void clear_createrolerequest();
  static const int kCreateRoleRequestFieldNumber = 7;
  const ::PBMessage::CreateRoleRequest& createrolerequest() const;
  ::PBMessage::CreateRoleRequest* mutable_createrolerequest();
  ::PBMessage::CreateRoleRequest* release_createrolerequest();
  void set_allocated_createrolerequest(::PBMessage::CreateRoleRequest* createrolerequest);

  // optional .PBMessage.CreateRoleReturn createRoleReturn = 8;
  bool has_createrolereturn() const;
  void clear_createrolereturn();
  static const int kCreateRoleReturnFieldNumber = 8;
  const ::PBMessage::CreateRoleReturn& createrolereturn() const;
  ::PBMessage::CreateRoleReturn* mutable_createrolereturn();
  ::PBMessage::CreateRoleReturn* release_createrolereturn();
  void set_allocated_createrolereturn(::PBMessage::CreateRoleReturn* createrolereturn);

  // optional .PBMessage.SelectRoleRequest selectRoleRequest = 9;
  bool has_selectrolerequest() const;
  void clear_selectrolerequest();
  static const int kSelectRoleRequestFieldNumber = 9;
  const ::PBMessage::SelectRoleRequest& selectrolerequest() const;
  ::PBMessage::SelectRoleRequest* mutable_selectrolerequest();
  ::PBMessage::SelectRoleRequest* release_selectrolerequest();
  void set_allocated_selectrolerequest(::PBMessage::SelectRoleRequest* selectrolerequest);

  // optional .PBMessage.SelectRoleReturn selectRoleReturn = 10;
  bool has_selectrolereturn() const;
  void clear_selectrolereturn();
  static const int kSelectRoleReturnFieldNumber = 10;
  const ::PBMessage::SelectRoleReturn& selectrolereturn() const;
  ::PBMessage::SelectRoleReturn* mutable_selectrolereturn();
  ::PBMessage::SelectRoleReturn* release_selectrolereturn();
  void set_allocated_selectrolereturn(::PBMessage::SelectRoleReturn* selectrolereturn);

  // optional .PBMessage.HallRequest hallRequest = 11;
  bool has_hallrequest() const;
  void clear_hallrequest();
  static const int kHallRequestFieldNumber = 11;
  const ::PBMessage::HallRequest& hallrequest() const;
  ::PBMessage::HallRequest* mutable_hallrequest();
  ::PBMessage::HallRequest* release_hallrequest();
  void set_allocated_hallrequest(::PBMessage::HallRequest* hallrequest);

  // optional .PBMessage.HallReturn hallReturn = 12;
  bool has_hallreturn() const;
  void clear_hallreturn();
  static const int kHallReturnFieldNumber = 12;
  const ::PBMessage::HallReturn& hallreturn() const;
  ::PBMessage::HallReturn* mutable_hallreturn();
  ::PBMessage::HallReturn* release_hallreturn();
  void set_allocated_hallreturn(::PBMessage::HallReturn* hallreturn);

  // optional .PBMessage.GameMainRequest gameMainRequest = 13;
  bool has_gamemainrequest() const;
  void clear_gamemainrequest();
  static const int kGameMainRequestFieldNumber = 13;
  const ::PBMessage::GameMainRequest& gamemainrequest() const;
  ::PBMessage::GameMainRequest* mutable_gamemainrequest();
  ::PBMessage::GameMainRequest* release_gamemainrequest();
  void set_allocated_gamemainrequest(::PBMessage::GameMainRequest* gamemainrequest);

  // optional .PBMessage.GameMainReturn gameMainReturn = 14;
  bool has_gamemainreturn() const;
  void clear_gamemainreturn();
  static const int kGameMainReturnFieldNumber = 14;
  const ::PBMessage::GameMainReturn& gamemainreturn() const;
  ::PBMessage::GameMainReturn* mutable_gamemainreturn();
  ::PBMessage::GameMainReturn* release_gamemainreturn();
  void set_allocated_gamemainreturn(::PBMessage::GameMainReturn* gamemainreturn);

  // optional .PBMessage.KeepAliveMsg keepAlive = 15;
  bool has_keepalive() const;
  void clear_keepalive();
  static const int kKeepAliveFieldNumber = 15;
  const ::PBMessage::KeepAliveMsg& keepalive() const;
  ::PBMessage::KeepAliveMsg* mutable_keepalive();
  ::PBMessage::KeepAliveMsg* release_keepalive();
  void set_allocated_keepalive(::PBMessage::KeepAliveMsg* keepalive);

  // required .PBMessage.CurScene curScene = 1;
  bool has_curscene() const;
  void clear_curscene();
  static const int kCurSceneFieldNumber = 1;
  ::PBMessage::CurScene curscene() const;
  void set_curscene(::PBMessage::CurScene value);

  // optional .PBMessage.MessageType msgType = 2;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgTypeFieldNumber = 2;
  ::PBMessage::MessageType msgtype() const;
  void set_msgtype(::PBMessage::MessageType value);

  // @@protoc_insertion_point(class_scope:PBMessage.UnPacket)
 private:
  void set_has_curscene();
  void clear_has_curscene();
  void set_has_msgtype();
  void clear_has_msgtype();
  void set_has_loginrequest();
  void clear_has_loginrequest();
  void set_has_loginreturn();
  void clear_has_loginreturn();
  void set_has_registerrequest();
  void clear_has_registerrequest();
  void set_has_registerreturn();
  void clear_has_registerreturn();
  void set_has_createrolerequest();
  void clear_has_createrolerequest();
  void set_has_createrolereturn();
  void clear_has_createrolereturn();
  void set_has_selectrolerequest();
  void clear_has_selectrolerequest();
  void set_has_selectrolereturn();
  void clear_has_selectrolereturn();
  void set_has_hallrequest();
  void clear_has_hallrequest();
  void set_has_hallreturn();
  void clear_has_hallreturn();
  void set_has_gamemainrequest();
  void clear_has_gamemainrequest();
  void set_has_gamemainreturn();
  void clear_has_gamemainreturn();
  void set_has_keepalive();
  void clear_has_keepalive();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::PBMessage::LoginRequest* loginrequest_;
  ::PBMessage::LoginReturn* loginreturn_;
  ::PBMessage::RegisterRequest* registerrequest_;
  ::PBMessage::RegisterReturn* registerreturn_;
  ::PBMessage::CreateRoleRequest* createrolerequest_;
  ::PBMessage::CreateRoleReturn* createrolereturn_;
  ::PBMessage::SelectRoleRequest* selectrolerequest_;
  ::PBMessage::SelectRoleReturn* selectrolereturn_;
  ::PBMessage::HallRequest* hallrequest_;
  ::PBMessage::HallReturn* hallreturn_;
  ::PBMessage::GameMainRequest* gamemainrequest_;
  ::PBMessage::GameMainReturn* gamemainreturn_;
  ::PBMessage::KeepAliveMsg* keepalive_;
  int curscene_;
  int msgtype_;
  friend struct protobuf_command_2etxt::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CMD_ReleaseSkill

// required int32 roleId = 1;
inline bool CMD_ReleaseSkill::has_roleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD_ReleaseSkill::set_has_roleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD_ReleaseSkill::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD_ReleaseSkill::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 CMD_ReleaseSkill::roleid() const {
  // @@protoc_insertion_point(field_get:PBMessage.CMD_ReleaseSkill.roleId)
  return roleid_;
}
inline void CMD_ReleaseSkill::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.CMD_ReleaseSkill.roleId)
}

// required int32 skillId = 2;
inline bool CMD_ReleaseSkill::has_skillid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMD_ReleaseSkill::set_has_skillid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMD_ReleaseSkill::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMD_ReleaseSkill::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 CMD_ReleaseSkill::skillid() const {
  // @@protoc_insertion_point(field_get:PBMessage.CMD_ReleaseSkill.skillId)
  return skillid_;
}
inline void CMD_ReleaseSkill::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.CMD_ReleaseSkill.skillId)
}

// required .PBMessage.Position3D mouseposition = 3;
inline bool CMD_ReleaseSkill::has_mouseposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_ReleaseSkill::set_has_mouseposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_ReleaseSkill::clear_has_mouseposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_ReleaseSkill::clear_mouseposition() {
  if (mouseposition_ != NULL) mouseposition_->::PBMessage::Position3D::Clear();
  clear_has_mouseposition();
}
inline const ::PBMessage::Position3D& CMD_ReleaseSkill::mouseposition() const {
  // @@protoc_insertion_point(field_get:PBMessage.CMD_ReleaseSkill.mouseposition)
  return mouseposition_ != NULL ? *mouseposition_
                         : *::PBMessage::Position3D::internal_default_instance();
}
inline ::PBMessage::Position3D* CMD_ReleaseSkill::mutable_mouseposition() {
  set_has_mouseposition();
  if (mouseposition_ == NULL) {
    mouseposition_ = new ::PBMessage::Position3D;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.CMD_ReleaseSkill.mouseposition)
  return mouseposition_;
}
inline ::PBMessage::Position3D* CMD_ReleaseSkill::release_mouseposition() {
  // @@protoc_insertion_point(field_release:PBMessage.CMD_ReleaseSkill.mouseposition)
  clear_has_mouseposition();
  ::PBMessage::Position3D* temp = mouseposition_;
  mouseposition_ = NULL;
  return temp;
}
inline void CMD_ReleaseSkill::set_allocated_mouseposition(::PBMessage::Position3D* mouseposition) {
  delete mouseposition_;
  mouseposition_ = mouseposition;
  if (mouseposition) {
    set_has_mouseposition();
  } else {
    clear_has_mouseposition();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.CMD_ReleaseSkill.mouseposition)
}

// -------------------------------------------------------------------

// CMD_MoveToPoint

// required int32 roleId = 1;
inline bool CMD_MoveToPoint::has_roleid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMD_MoveToPoint::set_has_roleid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMD_MoveToPoint::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMD_MoveToPoint::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 CMD_MoveToPoint::roleid() const {
  // @@protoc_insertion_point(field_get:PBMessage.CMD_MoveToPoint.roleId)
  return roleid_;
}
inline void CMD_MoveToPoint::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.CMD_MoveToPoint.roleId)
}

// required .PBMessage.Position3D position = 2;
inline bool CMD_MoveToPoint::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_MoveToPoint::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_MoveToPoint::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_MoveToPoint::clear_position() {
  if (position_ != NULL) position_->::PBMessage::Position3D::Clear();
  clear_has_position();
}
inline const ::PBMessage::Position3D& CMD_MoveToPoint::position() const {
  // @@protoc_insertion_point(field_get:PBMessage.CMD_MoveToPoint.position)
  return position_ != NULL ? *position_
                         : *::PBMessage::Position3D::internal_default_instance();
}
inline ::PBMessage::Position3D* CMD_MoveToPoint::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::PBMessage::Position3D;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.CMD_MoveToPoint.position)
  return position_;
}
inline ::PBMessage::Position3D* CMD_MoveToPoint::release_position() {
  // @@protoc_insertion_point(field_release:PBMessage.CMD_MoveToPoint.position)
  clear_has_position();
  ::PBMessage::Position3D* temp = position_;
  position_ = NULL;
  return temp;
}
inline void CMD_MoveToPoint::set_allocated_position(::PBMessage::Position3D* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.CMD_MoveToPoint.position)
}

// required .PBMessage.Position3D direction = 3;
inline bool CMD_MoveToPoint::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD_MoveToPoint::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD_MoveToPoint::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD_MoveToPoint::clear_direction() {
  if (direction_ != NULL) direction_->::PBMessage::Position3D::Clear();
  clear_has_direction();
}
inline const ::PBMessage::Position3D& CMD_MoveToPoint::direction() const {
  // @@protoc_insertion_point(field_get:PBMessage.CMD_MoveToPoint.direction)
  return direction_ != NULL ? *direction_
                         : *::PBMessage::Position3D::internal_default_instance();
}
inline ::PBMessage::Position3D* CMD_MoveToPoint::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::PBMessage::Position3D;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.CMD_MoveToPoint.direction)
  return direction_;
}
inline ::PBMessage::Position3D* CMD_MoveToPoint::release_direction() {
  // @@protoc_insertion_point(field_release:PBMessage.CMD_MoveToPoint.direction)
  clear_has_direction();
  ::PBMessage::Position3D* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void CMD_MoveToPoint::set_allocated_direction(::PBMessage::Position3D* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.CMD_MoveToPoint.direction)
}

// required .PBMessage.Position3D destination = 4;
inline bool CMD_MoveToPoint::has_destination() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMD_MoveToPoint::set_has_destination() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMD_MoveToPoint::clear_has_destination() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMD_MoveToPoint::clear_destination() {
  if (destination_ != NULL) destination_->::PBMessage::Position3D::Clear();
  clear_has_destination();
}
inline const ::PBMessage::Position3D& CMD_MoveToPoint::destination() const {
  // @@protoc_insertion_point(field_get:PBMessage.CMD_MoveToPoint.destination)
  return destination_ != NULL ? *destination_
                         : *::PBMessage::Position3D::internal_default_instance();
}
inline ::PBMessage::Position3D* CMD_MoveToPoint::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) {
    destination_ = new ::PBMessage::Position3D;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.CMD_MoveToPoint.destination)
  return destination_;
}
inline ::PBMessage::Position3D* CMD_MoveToPoint::release_destination() {
  // @@protoc_insertion_point(field_release:PBMessage.CMD_MoveToPoint.destination)
  clear_has_destination();
  ::PBMessage::Position3D* temp = destination_;
  destination_ = NULL;
  return temp;
}
inline void CMD_MoveToPoint::set_allocated_destination(::PBMessage::Position3D* destination) {
  delete destination_;
  destination_ = destination;
  if (destination) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.CMD_MoveToPoint.destination)
}

// -------------------------------------------------------------------

// Disconnect

// required int32 roleId = 1;
inline bool Disconnect::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Disconnect::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Disconnect::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Disconnect::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 Disconnect::roleid() const {
  // @@protoc_insertion_point(field_get:PBMessage.Disconnect.roleId)
  return roleid_;
}
inline void Disconnect::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.Disconnect.roleId)
}

// -------------------------------------------------------------------

// KeepAliveMsg

// required .PBMessage.CurScene curScene = 1;
inline bool KeepAliveMsg::has_curscene() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeepAliveMsg::set_has_curscene() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeepAliveMsg::clear_has_curscene() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeepAliveMsg::clear_curscene() {
  curscene_ = 0;
  clear_has_curscene();
}
inline ::PBMessage::CurScene KeepAliveMsg::curscene() const {
  // @@protoc_insertion_point(field_get:PBMessage.KeepAliveMsg.curScene)
  return static_cast< ::PBMessage::CurScene >(curscene_);
}
inline void KeepAliveMsg::set_curscene(::PBMessage::CurScene value) {
  assert(::PBMessage::CurScene_IsValid(value));
  set_has_curscene();
  curscene_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.KeepAliveMsg.curScene)
}

// -------------------------------------------------------------------

// LoginRequest

// required string userName = 1;
inline bool LoginRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& LoginRequest::username() const {
  // @@protoc_insertion_point(field_get:PBMessage.LoginRequest.userName)
  return username_.GetNoArena();
}
inline void LoginRequest::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PBMessage.LoginRequest.userName)
}
#if LANG_CXX11
inline void LoginRequest::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PBMessage.LoginRequest.userName)
}
#endif
inline void LoginRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PBMessage.LoginRequest.userName)
}
inline void LoginRequest::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PBMessage.LoginRequest.userName)
}
inline ::std::string* LoginRequest::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:PBMessage.LoginRequest.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:PBMessage.LoginRequest.userName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:PBMessage.LoginRequest.userName)
}

// required string passWord = 2;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:PBMessage.LoginRequest.passWord)
  return password_.GetNoArena();
}
inline void LoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PBMessage.LoginRequest.passWord)
}
#if LANG_CXX11
inline void LoginRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PBMessage.LoginRequest.passWord)
}
#endif
inline void LoginRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PBMessage.LoginRequest.passWord)
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PBMessage.LoginRequest.passWord)
}
inline ::std::string* LoginRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:PBMessage.LoginRequest.passWord)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:PBMessage.LoginRequest.passWord)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:PBMessage.LoginRequest.passWord)
}

// -------------------------------------------------------------------

// LoginReturn

// required string sessionID = 1;
inline bool LoginReturn::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReturn::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReturn::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReturn::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sessionid();
}
inline const ::std::string& LoginReturn::sessionid() const {
  // @@protoc_insertion_point(field_get:PBMessage.LoginReturn.sessionID)
  return sessionid_.GetNoArena();
}
inline void LoginReturn::set_sessionid(const ::std::string& value) {
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PBMessage.LoginReturn.sessionID)
}
#if LANG_CXX11
inline void LoginReturn::set_sessionid(::std::string&& value) {
  set_has_sessionid();
  sessionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PBMessage.LoginReturn.sessionID)
}
#endif
inline void LoginReturn::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PBMessage.LoginReturn.sessionID)
}
inline void LoginReturn::set_sessionid(const char* value, size_t size) {
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PBMessage.LoginReturn.sessionID)
}
inline ::std::string* LoginReturn::mutable_sessionid() {
  set_has_sessionid();
  // @@protoc_insertion_point(field_mutable:PBMessage.LoginReturn.sessionID)
  return sessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReturn::release_sessionid() {
  // @@protoc_insertion_point(field_release:PBMessage.LoginReturn.sessionID)
  clear_has_sessionid();
  return sessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReturn::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid != NULL) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
  sessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:PBMessage.LoginReturn.sessionID)
}

// required .PBMessage.LoginReturnType returnType = 2;
inline bool LoginReturn::has_returntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReturn::set_has_returntype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReturn::clear_has_returntype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReturn::clear_returntype() {
  returntype_ = 0;
  clear_has_returntype();
}
inline ::PBMessage::LoginReturnType LoginReturn::returntype() const {
  // @@protoc_insertion_point(field_get:PBMessage.LoginReturn.returnType)
  return static_cast< ::PBMessage::LoginReturnType >(returntype_);
}
inline void LoginReturn::set_returntype(::PBMessage::LoginReturnType value) {
  assert(::PBMessage::LoginReturnType_IsValid(value));
  set_has_returntype();
  returntype_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.LoginReturn.returnType)
}

// repeated .PBMessage.PlayerInfo playerInfo = 3;
inline int LoginReturn::playerinfo_size() const {
  return playerinfo_.size();
}
inline void LoginReturn::clear_playerinfo() {
  playerinfo_.Clear();
}
inline const ::PBMessage::PlayerInfo& LoginReturn::playerinfo(int index) const {
  // @@protoc_insertion_point(field_get:PBMessage.LoginReturn.playerInfo)
  return playerinfo_.Get(index);
}
inline ::PBMessage::PlayerInfo* LoginReturn::mutable_playerinfo(int index) {
  // @@protoc_insertion_point(field_mutable:PBMessage.LoginReturn.playerInfo)
  return playerinfo_.Mutable(index);
}
inline ::PBMessage::PlayerInfo* LoginReturn::add_playerinfo() {
  // @@protoc_insertion_point(field_add:PBMessage.LoginReturn.playerInfo)
  return playerinfo_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >*
LoginReturn::mutable_playerinfo() {
  // @@protoc_insertion_point(field_mutable_list:PBMessage.LoginReturn.playerInfo)
  return &playerinfo_;
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >&
LoginReturn::playerinfo() const {
  // @@protoc_insertion_point(field_list:PBMessage.LoginReturn.playerInfo)
  return playerinfo_;
}

// -------------------------------------------------------------------

// RegisterRequest

// required string userName = 1;
inline bool RegisterRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& RegisterRequest::username() const {
  // @@protoc_insertion_point(field_get:PBMessage.RegisterRequest.userName)
  return username_.GetNoArena();
}
inline void RegisterRequest::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PBMessage.RegisterRequest.userName)
}
#if LANG_CXX11
inline void RegisterRequest::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PBMessage.RegisterRequest.userName)
}
#endif
inline void RegisterRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PBMessage.RegisterRequest.userName)
}
inline void RegisterRequest::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PBMessage.RegisterRequest.userName)
}
inline ::std::string* RegisterRequest::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:PBMessage.RegisterRequest.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_username() {
  // @@protoc_insertion_point(field_release:PBMessage.RegisterRequest.userName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:PBMessage.RegisterRequest.userName)
}

// required string passWord = 2;
inline bool RegisterRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& RegisterRequest::password() const {
  // @@protoc_insertion_point(field_get:PBMessage.RegisterRequest.passWord)
  return password_.GetNoArena();
}
inline void RegisterRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PBMessage.RegisterRequest.passWord)
}
#if LANG_CXX11
inline void RegisterRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PBMessage.RegisterRequest.passWord)
}
#endif
inline void RegisterRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PBMessage.RegisterRequest.passWord)
}
inline void RegisterRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PBMessage.RegisterRequest.passWord)
}
inline ::std::string* RegisterRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:PBMessage.RegisterRequest.passWord)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_password() {
  // @@protoc_insertion_point(field_release:PBMessage.RegisterRequest.passWord)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:PBMessage.RegisterRequest.passWord)
}

// -------------------------------------------------------------------

// RegisterReturn

// required .PBMessage.RegisterReturnType returnType = 1;
inline bool RegisterReturn::has_returntype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterReturn::set_has_returntype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterReturn::clear_has_returntype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterReturn::clear_returntype() {
  returntype_ = 0;
  clear_has_returntype();
}
inline ::PBMessage::RegisterReturnType RegisterReturn::returntype() const {
  // @@protoc_insertion_point(field_get:PBMessage.RegisterReturn.returnType)
  return static_cast< ::PBMessage::RegisterReturnType >(returntype_);
}
inline void RegisterReturn::set_returntype(::PBMessage::RegisterReturnType value) {
  assert(::PBMessage::RegisterReturnType_IsValid(value));
  set_has_returntype();
  returntype_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.RegisterReturn.returnType)
}

// -------------------------------------------------------------------

// CreateRoleRequest

// required string sessionID = 1;
inline bool CreateRoleRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoleRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoleRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoleRequest::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sessionid();
}
inline const ::std::string& CreateRoleRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:PBMessage.CreateRoleRequest.sessionID)
  return sessionid_.GetNoArena();
}
inline void CreateRoleRequest::set_sessionid(const ::std::string& value) {
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PBMessage.CreateRoleRequest.sessionID)
}
#if LANG_CXX11
inline void CreateRoleRequest::set_sessionid(::std::string&& value) {
  set_has_sessionid();
  sessionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PBMessage.CreateRoleRequest.sessionID)
}
#endif
inline void CreateRoleRequest::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PBMessage.CreateRoleRequest.sessionID)
}
inline void CreateRoleRequest::set_sessionid(const char* value, size_t size) {
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PBMessage.CreateRoleRequest.sessionID)
}
inline ::std::string* CreateRoleRequest::mutable_sessionid() {
  set_has_sessionid();
  // @@protoc_insertion_point(field_mutable:PBMessage.CreateRoleRequest.sessionID)
  return sessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoleRequest::release_sessionid() {
  // @@protoc_insertion_point(field_release:PBMessage.CreateRoleRequest.sessionID)
  clear_has_sessionid();
  return sessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoleRequest::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid != NULL) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
  sessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:PBMessage.CreateRoleRequest.sessionID)
}

// required .PBMessage.PlayerInfo playerInfo = 2;
inline bool CreateRoleRequest::has_playerinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoleRequest::set_has_playerinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoleRequest::clear_has_playerinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoleRequest::clear_playerinfo() {
  if (playerinfo_ != NULL) playerinfo_->::PBMessage::PlayerInfo::Clear();
  clear_has_playerinfo();
}
inline const ::PBMessage::PlayerInfo& CreateRoleRequest::playerinfo() const {
  // @@protoc_insertion_point(field_get:PBMessage.CreateRoleRequest.playerInfo)
  return playerinfo_ != NULL ? *playerinfo_
                         : *::PBMessage::PlayerInfo::internal_default_instance();
}
inline ::PBMessage::PlayerInfo* CreateRoleRequest::mutable_playerinfo() {
  set_has_playerinfo();
  if (playerinfo_ == NULL) {
    playerinfo_ = new ::PBMessage::PlayerInfo;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.CreateRoleRequest.playerInfo)
  return playerinfo_;
}
inline ::PBMessage::PlayerInfo* CreateRoleRequest::release_playerinfo() {
  // @@protoc_insertion_point(field_release:PBMessage.CreateRoleRequest.playerInfo)
  clear_has_playerinfo();
  ::PBMessage::PlayerInfo* temp = playerinfo_;
  playerinfo_ = NULL;
  return temp;
}
inline void CreateRoleRequest::set_allocated_playerinfo(::PBMessage::PlayerInfo* playerinfo) {
  delete playerinfo_;
  playerinfo_ = playerinfo;
  if (playerinfo) {
    set_has_playerinfo();
  } else {
    clear_has_playerinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.CreateRoleRequest.playerInfo)
}

// -------------------------------------------------------------------

// CreateRoleReturn

// required .PBMessage.CreateRoleReturnType returnType = 1;
inline bool CreateRoleReturn::has_returntype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoleReturn::set_has_returntype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoleReturn::clear_has_returntype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoleReturn::clear_returntype() {
  returntype_ = 0;
  clear_has_returntype();
}
inline ::PBMessage::CreateRoleReturnType CreateRoleReturn::returntype() const {
  // @@protoc_insertion_point(field_get:PBMessage.CreateRoleReturn.returnType)
  return static_cast< ::PBMessage::CreateRoleReturnType >(returntype_);
}
inline void CreateRoleReturn::set_returntype(::PBMessage::CreateRoleReturnType value) {
  assert(::PBMessage::CreateRoleReturnType_IsValid(value));
  set_has_returntype();
  returntype_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.CreateRoleReturn.returnType)
}

// repeated .PBMessage.PlayerInfo playerInfo = 2;
inline int CreateRoleReturn::playerinfo_size() const {
  return playerinfo_.size();
}
inline void CreateRoleReturn::clear_playerinfo() {
  playerinfo_.Clear();
}
inline const ::PBMessage::PlayerInfo& CreateRoleReturn::playerinfo(int index) const {
  // @@protoc_insertion_point(field_get:PBMessage.CreateRoleReturn.playerInfo)
  return playerinfo_.Get(index);
}
inline ::PBMessage::PlayerInfo* CreateRoleReturn::mutable_playerinfo(int index) {
  // @@protoc_insertion_point(field_mutable:PBMessage.CreateRoleReturn.playerInfo)
  return playerinfo_.Mutable(index);
}
inline ::PBMessage::PlayerInfo* CreateRoleReturn::add_playerinfo() {
  // @@protoc_insertion_point(field_add:PBMessage.CreateRoleReturn.playerInfo)
  return playerinfo_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >*
CreateRoleReturn::mutable_playerinfo() {
  // @@protoc_insertion_point(field_mutable_list:PBMessage.CreateRoleReturn.playerInfo)
  return &playerinfo_;
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >&
CreateRoleReturn::playerinfo() const {
  // @@protoc_insertion_point(field_list:PBMessage.CreateRoleReturn.playerInfo)
  return playerinfo_;
}

// -------------------------------------------------------------------

// SelectRoleRequest

// required string sessionID = 1;
inline bool SelectRoleRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelectRoleRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelectRoleRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelectRoleRequest::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sessionid();
}
inline const ::std::string& SelectRoleRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:PBMessage.SelectRoleRequest.sessionID)
  return sessionid_.GetNoArena();
}
inline void SelectRoleRequest::set_sessionid(const ::std::string& value) {
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PBMessage.SelectRoleRequest.sessionID)
}
#if LANG_CXX11
inline void SelectRoleRequest::set_sessionid(::std::string&& value) {
  set_has_sessionid();
  sessionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PBMessage.SelectRoleRequest.sessionID)
}
#endif
inline void SelectRoleRequest::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PBMessage.SelectRoleRequest.sessionID)
}
inline void SelectRoleRequest::set_sessionid(const char* value, size_t size) {
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PBMessage.SelectRoleRequest.sessionID)
}
inline ::std::string* SelectRoleRequest::mutable_sessionid() {
  set_has_sessionid();
  // @@protoc_insertion_point(field_mutable:PBMessage.SelectRoleRequest.sessionID)
  return sessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SelectRoleRequest::release_sessionid() {
  // @@protoc_insertion_point(field_release:PBMessage.SelectRoleRequest.sessionID)
  clear_has_sessionid();
  return sessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SelectRoleRequest::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid != NULL) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
  sessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:PBMessage.SelectRoleRequest.sessionID)
}

// required int32 roleType = 2;
inline bool SelectRoleRequest::has_roletype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SelectRoleRequest::set_has_roletype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SelectRoleRequest::clear_has_roletype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SelectRoleRequest::clear_roletype() {
  roletype_ = 0;
  clear_has_roletype();
}
inline ::google::protobuf::int32 SelectRoleRequest::roletype() const {
  // @@protoc_insertion_point(field_get:PBMessage.SelectRoleRequest.roleType)
  return roletype_;
}
inline void SelectRoleRequest::set_roletype(::google::protobuf::int32 value) {
  set_has_roletype();
  roletype_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.SelectRoleRequest.roleType)
}

// -------------------------------------------------------------------

// SelectRoleReturn

// required int32 userId = 1;
inline bool SelectRoleReturn::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelectRoleReturn::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelectRoleReturn::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelectRoleReturn::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 SelectRoleReturn::userid() const {
  // @@protoc_insertion_point(field_get:PBMessage.SelectRoleReturn.userId)
  return userid_;
}
inline void SelectRoleReturn::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.SelectRoleReturn.userId)
}

// -------------------------------------------------------------------

// HallRequest

// required string sessionID = 1;
inline bool HallRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HallRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HallRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HallRequest::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sessionid();
}
inline const ::std::string& HallRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:PBMessage.HallRequest.sessionID)
  return sessionid_.GetNoArena();
}
inline void HallRequest::set_sessionid(const ::std::string& value) {
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PBMessage.HallRequest.sessionID)
}
#if LANG_CXX11
inline void HallRequest::set_sessionid(::std::string&& value) {
  set_has_sessionid();
  sessionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PBMessage.HallRequest.sessionID)
}
#endif
inline void HallRequest::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PBMessage.HallRequest.sessionID)
}
inline void HallRequest::set_sessionid(const char* value, size_t size) {
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PBMessage.HallRequest.sessionID)
}
inline ::std::string* HallRequest::mutable_sessionid() {
  set_has_sessionid();
  // @@protoc_insertion_point(field_mutable:PBMessage.HallRequest.sessionID)
  return sessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HallRequest::release_sessionid() {
  // @@protoc_insertion_point(field_release:PBMessage.HallRequest.sessionID)
  clear_has_sessionid();
  return sessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HallRequest::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid != NULL) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
  sessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:PBMessage.HallRequest.sessionID)
}

// required .PBMessage.HallMsgType MsgType = 2;
inline bool HallRequest::has_msgtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HallRequest::set_has_msgtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HallRequest::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HallRequest::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::PBMessage::HallMsgType HallRequest::msgtype() const {
  // @@protoc_insertion_point(field_get:PBMessage.HallRequest.MsgType)
  return static_cast< ::PBMessage::HallMsgType >(msgtype_);
}
inline void HallRequest::set_msgtype(::PBMessage::HallMsgType value) {
  assert(::PBMessage::HallMsgType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.HallRequest.MsgType)
}

// optional string roomName = 3;
inline bool HallRequest::has_roomname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HallRequest::set_has_roomname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HallRequest::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HallRequest::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roomname();
}
inline const ::std::string& HallRequest::roomname() const {
  // @@protoc_insertion_point(field_get:PBMessage.HallRequest.roomName)
  return roomname_.GetNoArena();
}
inline void HallRequest::set_roomname(const ::std::string& value) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PBMessage.HallRequest.roomName)
}
#if LANG_CXX11
inline void HallRequest::set_roomname(::std::string&& value) {
  set_has_roomname();
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PBMessage.HallRequest.roomName)
}
#endif
inline void HallRequest::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PBMessage.HallRequest.roomName)
}
inline void HallRequest::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PBMessage.HallRequest.roomName)
}
inline ::std::string* HallRequest::mutable_roomname() {
  set_has_roomname();
  // @@protoc_insertion_point(field_mutable:PBMessage.HallRequest.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HallRequest::release_roomname() {
  // @@protoc_insertion_point(field_release:PBMessage.HallRequest.roomName)
  clear_has_roomname();
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HallRequest::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    set_has_roomname();
  } else {
    clear_has_roomname();
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:PBMessage.HallRequest.roomName)
}

// optional int32 userId = 4;
inline bool HallRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HallRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HallRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HallRequest::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 HallRequest::userid() const {
  // @@protoc_insertion_point(field_get:PBMessage.HallRequest.userId)
  return userid_;
}
inline void HallRequest::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.HallRequest.userId)
}

// optional .PBMessage.InviteInfo inviteInfo = 5;
inline bool HallRequest::has_inviteinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HallRequest::set_has_inviteinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HallRequest::clear_has_inviteinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HallRequest::clear_inviteinfo() {
  if (inviteinfo_ != NULL) inviteinfo_->::PBMessage::InviteInfo::Clear();
  clear_has_inviteinfo();
}
inline const ::PBMessage::InviteInfo& HallRequest::inviteinfo() const {
  // @@protoc_insertion_point(field_get:PBMessage.HallRequest.inviteInfo)
  return inviteinfo_ != NULL ? *inviteinfo_
                         : *::PBMessage::InviteInfo::internal_default_instance();
}
inline ::PBMessage::InviteInfo* HallRequest::mutable_inviteinfo() {
  set_has_inviteinfo();
  if (inviteinfo_ == NULL) {
    inviteinfo_ = new ::PBMessage::InviteInfo;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.HallRequest.inviteInfo)
  return inviteinfo_;
}
inline ::PBMessage::InviteInfo* HallRequest::release_inviteinfo() {
  // @@protoc_insertion_point(field_release:PBMessage.HallRequest.inviteInfo)
  clear_has_inviteinfo();
  ::PBMessage::InviteInfo* temp = inviteinfo_;
  inviteinfo_ = NULL;
  return temp;
}
inline void HallRequest::set_allocated_inviteinfo(::PBMessage::InviteInfo* inviteinfo) {
  delete inviteinfo_;
  inviteinfo_ = inviteinfo;
  if (inviteinfo) {
    set_has_inviteinfo();
  } else {
    clear_has_inviteinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.HallRequest.inviteInfo)
}

// -------------------------------------------------------------------

// HallReturn

// optional .PBMessage.HallInfo hallInfo = 1;
inline bool HallReturn::has_hallinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HallReturn::set_has_hallinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HallReturn::clear_has_hallinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HallReturn::clear_hallinfo() {
  if (hallinfo_ != NULL) hallinfo_->::PBMessage::HallInfo::Clear();
  clear_has_hallinfo();
}
inline const ::PBMessage::HallInfo& HallReturn::hallinfo() const {
  // @@protoc_insertion_point(field_get:PBMessage.HallReturn.hallInfo)
  return hallinfo_ != NULL ? *hallinfo_
                         : *::PBMessage::HallInfo::internal_default_instance();
}
inline ::PBMessage::HallInfo* HallReturn::mutable_hallinfo() {
  set_has_hallinfo();
  if (hallinfo_ == NULL) {
    hallinfo_ = new ::PBMessage::HallInfo;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.HallReturn.hallInfo)
  return hallinfo_;
}
inline ::PBMessage::HallInfo* HallReturn::release_hallinfo() {
  // @@protoc_insertion_point(field_release:PBMessage.HallReturn.hallInfo)
  clear_has_hallinfo();
  ::PBMessage::HallInfo* temp = hallinfo_;
  hallinfo_ = NULL;
  return temp;
}
inline void HallReturn::set_allocated_hallinfo(::PBMessage::HallInfo* hallinfo) {
  delete hallinfo_;
  hallinfo_ = hallinfo;
  if (hallinfo) {
    set_has_hallinfo();
  } else {
    clear_has_hallinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.HallReturn.hallInfo)
}

// optional .PBMessage.HallMsgType MsgType = 2;
inline bool HallReturn::has_msgtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HallReturn::set_has_msgtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HallReturn::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HallReturn::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::PBMessage::HallMsgType HallReturn::msgtype() const {
  // @@protoc_insertion_point(field_get:PBMessage.HallReturn.MsgType)
  return static_cast< ::PBMessage::HallMsgType >(msgtype_);
}
inline void HallReturn::set_msgtype(::PBMessage::HallMsgType value) {
  assert(::PBMessage::HallMsgType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.HallReturn.MsgType)
}

// optional string roomName = 3;
inline bool HallReturn::has_roomname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HallReturn::set_has_roomname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HallReturn::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HallReturn::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roomname();
}
inline const ::std::string& HallReturn::roomname() const {
  // @@protoc_insertion_point(field_get:PBMessage.HallReturn.roomName)
  return roomname_.GetNoArena();
}
inline void HallReturn::set_roomname(const ::std::string& value) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PBMessage.HallReturn.roomName)
}
#if LANG_CXX11
inline void HallReturn::set_roomname(::std::string&& value) {
  set_has_roomname();
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PBMessage.HallReturn.roomName)
}
#endif
inline void HallReturn::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PBMessage.HallReturn.roomName)
}
inline void HallReturn::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PBMessage.HallReturn.roomName)
}
inline ::std::string* HallReturn::mutable_roomname() {
  set_has_roomname();
  // @@protoc_insertion_point(field_mutable:PBMessage.HallReturn.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HallReturn::release_roomname() {
  // @@protoc_insertion_point(field_release:PBMessage.HallReturn.roomName)
  clear_has_roomname();
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HallReturn::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    set_has_roomname();
  } else {
    clear_has_roomname();
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:PBMessage.HallReturn.roomName)
}

// optional int32 roomID = 4;
inline bool HallReturn::has_roomid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HallReturn::set_has_roomid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HallReturn::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HallReturn::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 HallReturn::roomid() const {
  // @@protoc_insertion_point(field_get:PBMessage.HallReturn.roomID)
  return roomid_;
}
inline void HallReturn::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.HallReturn.roomID)
}

// repeated .PBMessage.PlayerInfo friendList = 5;
inline int HallReturn::friendlist_size() const {
  return friendlist_.size();
}
inline void HallReturn::clear_friendlist() {
  friendlist_.Clear();
}
inline const ::PBMessage::PlayerInfo& HallReturn::friendlist(int index) const {
  // @@protoc_insertion_point(field_get:PBMessage.HallReturn.friendList)
  return friendlist_.Get(index);
}
inline ::PBMessage::PlayerInfo* HallReturn::mutable_friendlist(int index) {
  // @@protoc_insertion_point(field_mutable:PBMessage.HallReturn.friendList)
  return friendlist_.Mutable(index);
}
inline ::PBMessage::PlayerInfo* HallReturn::add_friendlist() {
  // @@protoc_insertion_point(field_add:PBMessage.HallReturn.friendList)
  return friendlist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >*
HallReturn::mutable_friendlist() {
  // @@protoc_insertion_point(field_mutable_list:PBMessage.HallReturn.friendList)
  return &friendlist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >&
HallReturn::friendlist() const {
  // @@protoc_insertion_point(field_list:PBMessage.HallReturn.friendList)
  return friendlist_;
}

// optional .PBMessage.InviteInfo inviteInfo = 6;
inline bool HallReturn::has_inviteinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HallReturn::set_has_inviteinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HallReturn::clear_has_inviteinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HallReturn::clear_inviteinfo() {
  if (inviteinfo_ != NULL) inviteinfo_->::PBMessage::InviteInfo::Clear();
  clear_has_inviteinfo();
}
inline const ::PBMessage::InviteInfo& HallReturn::inviteinfo() const {
  // @@protoc_insertion_point(field_get:PBMessage.HallReturn.inviteInfo)
  return inviteinfo_ != NULL ? *inviteinfo_
                         : *::PBMessage::InviteInfo::internal_default_instance();
}
inline ::PBMessage::InviteInfo* HallReturn::mutable_inviteinfo() {
  set_has_inviteinfo();
  if (inviteinfo_ == NULL) {
    inviteinfo_ = new ::PBMessage::InviteInfo;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.HallReturn.inviteInfo)
  return inviteinfo_;
}
inline ::PBMessage::InviteInfo* HallReturn::release_inviteinfo() {
  // @@protoc_insertion_point(field_release:PBMessage.HallReturn.inviteInfo)
  clear_has_inviteinfo();
  ::PBMessage::InviteInfo* temp = inviteinfo_;
  inviteinfo_ = NULL;
  return temp;
}
inline void HallReturn::set_allocated_inviteinfo(::PBMessage::InviteInfo* inviteinfo) {
  delete inviteinfo_;
  inviteinfo_ = inviteinfo;
  if (inviteinfo) {
    set_has_inviteinfo();
  } else {
    clear_has_inviteinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.HallReturn.inviteInfo)
}

// -------------------------------------------------------------------

// GameMainRequest

// required string sessionID = 1;
inline bool GameMainRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMainRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMainRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMainRequest::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sessionid();
}
inline const ::std::string& GameMainRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:PBMessage.GameMainRequest.sessionID)
  return sessionid_.GetNoArena();
}
inline void GameMainRequest::set_sessionid(const ::std::string& value) {
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PBMessage.GameMainRequest.sessionID)
}
#if LANG_CXX11
inline void GameMainRequest::set_sessionid(::std::string&& value) {
  set_has_sessionid();
  sessionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PBMessage.GameMainRequest.sessionID)
}
#endif
inline void GameMainRequest::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PBMessage.GameMainRequest.sessionID)
}
inline void GameMainRequest::set_sessionid(const char* value, size_t size) {
  set_has_sessionid();
  sessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PBMessage.GameMainRequest.sessionID)
}
inline ::std::string* GameMainRequest::mutable_sessionid() {
  set_has_sessionid();
  // @@protoc_insertion_point(field_mutable:PBMessage.GameMainRequest.sessionID)
  return sessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameMainRequest::release_sessionid() {
  // @@protoc_insertion_point(field_release:PBMessage.GameMainRequest.sessionID)
  clear_has_sessionid();
  return sessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameMainRequest::set_allocated_sessionid(::std::string* sessionid) {
  if (sessionid != NULL) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
  sessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:PBMessage.GameMainRequest.sessionID)
}

// required .PBMessage.GameMainMsgType msgType = 2;
inline bool GameMainRequest::has_msgtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameMainRequest::set_has_msgtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameMainRequest::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameMainRequest::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::PBMessage::GameMainMsgType GameMainRequest::msgtype() const {
  // @@protoc_insertion_point(field_get:PBMessage.GameMainRequest.msgType)
  return static_cast< ::PBMessage::GameMainMsgType >(msgtype_);
}
inline void GameMainRequest::set_msgtype(::PBMessage::GameMainMsgType value) {
  assert(::PBMessage::GameMainMsgType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.GameMainRequest.msgType)
}

// optional .PBMessage.PlayerInfo playerInfo = 3;
inline bool GameMainRequest::has_playerinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameMainRequest::set_has_playerinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameMainRequest::clear_has_playerinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameMainRequest::clear_playerinfo() {
  if (playerinfo_ != NULL) playerinfo_->::PBMessage::PlayerInfo::Clear();
  clear_has_playerinfo();
}
inline const ::PBMessage::PlayerInfo& GameMainRequest::playerinfo() const {
  // @@protoc_insertion_point(field_get:PBMessage.GameMainRequest.playerInfo)
  return playerinfo_ != NULL ? *playerinfo_
                         : *::PBMessage::PlayerInfo::internal_default_instance();
}
inline ::PBMessage::PlayerInfo* GameMainRequest::mutable_playerinfo() {
  set_has_playerinfo();
  if (playerinfo_ == NULL) {
    playerinfo_ = new ::PBMessage::PlayerInfo;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.GameMainRequest.playerInfo)
  return playerinfo_;
}
inline ::PBMessage::PlayerInfo* GameMainRequest::release_playerinfo() {
  // @@protoc_insertion_point(field_release:PBMessage.GameMainRequest.playerInfo)
  clear_has_playerinfo();
  ::PBMessage::PlayerInfo* temp = playerinfo_;
  playerinfo_ = NULL;
  return temp;
}
inline void GameMainRequest::set_allocated_playerinfo(::PBMessage::PlayerInfo* playerinfo) {
  delete playerinfo_;
  playerinfo_ = playerinfo;
  if (playerinfo) {
    set_has_playerinfo();
  } else {
    clear_has_playerinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.GameMainRequest.playerInfo)
}

// -------------------------------------------------------------------

// GameMainReturn

// required .PBMessage.GameMainMsgType msgType = 1;
inline bool GameMainReturn::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMainReturn::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMainReturn::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMainReturn::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::PBMessage::GameMainMsgType GameMainReturn::msgtype() const {
  // @@protoc_insertion_point(field_get:PBMessage.GameMainReturn.msgType)
  return static_cast< ::PBMessage::GameMainMsgType >(msgtype_);
}
inline void GameMainReturn::set_msgtype(::PBMessage::GameMainMsgType value) {
  assert(::PBMessage::GameMainMsgType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.GameMainReturn.msgType)
}

// repeated .PBMessage.PlayerInfo friendList = 2;
inline int GameMainReturn::friendlist_size() const {
  return friendlist_.size();
}
inline void GameMainReturn::clear_friendlist() {
  friendlist_.Clear();
}
inline const ::PBMessage::PlayerInfo& GameMainReturn::friendlist(int index) const {
  // @@protoc_insertion_point(field_get:PBMessage.GameMainReturn.friendList)
  return friendlist_.Get(index);
}
inline ::PBMessage::PlayerInfo* GameMainReturn::mutable_friendlist(int index) {
  // @@protoc_insertion_point(field_mutable:PBMessage.GameMainReturn.friendList)
  return friendlist_.Mutable(index);
}
inline ::PBMessage::PlayerInfo* GameMainReturn::add_friendlist() {
  // @@protoc_insertion_point(field_add:PBMessage.GameMainReturn.friendList)
  return friendlist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >*
GameMainReturn::mutable_friendlist() {
  // @@protoc_insertion_point(field_mutable_list:PBMessage.GameMainReturn.friendList)
  return &friendlist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::PBMessage::PlayerInfo >&
GameMainReturn::friendlist() const {
  // @@protoc_insertion_point(field_list:PBMessage.GameMainReturn.friendList)
  return friendlist_;
}

// -------------------------------------------------------------------

// Packet

// required .PBMessage.CurScene curScene = 1;
inline bool Packet::has_curscene() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Packet::set_has_curscene() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Packet::clear_has_curscene() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Packet::clear_curscene() {
  curscene_ = 0;
  clear_has_curscene();
}
inline ::PBMessage::CurScene Packet::curscene() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.curScene)
  return static_cast< ::PBMessage::CurScene >(curscene_);
}
inline void Packet::set_curscene(::PBMessage::CurScene value) {
  assert(::PBMessage::CurScene_IsValid(value));
  set_has_curscene();
  curscene_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.Packet.curScene)
}

// optional .PBMessage.MessageType msgType = 2;
inline bool Packet::has_msgtype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Packet::set_has_msgtype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Packet::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Packet::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::PBMessage::MessageType Packet::msgtype() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.msgType)
  return static_cast< ::PBMessage::MessageType >(msgtype_);
}
inline void Packet::set_msgtype(::PBMessage::MessageType value) {
  assert(::PBMessage::MessageType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.Packet.msgType)
}

// optional .PBMessage.LoginRequest loginRequest = 3;
inline bool Packet::has_loginrequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet::set_has_loginrequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet::clear_has_loginrequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet::clear_loginrequest() {
  if (loginrequest_ != NULL) loginrequest_->::PBMessage::LoginRequest::Clear();
  clear_has_loginrequest();
}
inline const ::PBMessage::LoginRequest& Packet::loginrequest() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.loginRequest)
  return loginrequest_ != NULL ? *loginrequest_
                         : *::PBMessage::LoginRequest::internal_default_instance();
}
inline ::PBMessage::LoginRequest* Packet::mutable_loginrequest() {
  set_has_loginrequest();
  if (loginrequest_ == NULL) {
    loginrequest_ = new ::PBMessage::LoginRequest;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.loginRequest)
  return loginrequest_;
}
inline ::PBMessage::LoginRequest* Packet::release_loginrequest() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.loginRequest)
  clear_has_loginrequest();
  ::PBMessage::LoginRequest* temp = loginrequest_;
  loginrequest_ = NULL;
  return temp;
}
inline void Packet::set_allocated_loginrequest(::PBMessage::LoginRequest* loginrequest) {
  delete loginrequest_;
  loginrequest_ = loginrequest;
  if (loginrequest) {
    set_has_loginrequest();
  } else {
    clear_has_loginrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.loginRequest)
}

// optional .PBMessage.LoginReturn loginReturn = 4;
inline bool Packet::has_loginreturn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Packet::set_has_loginreturn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Packet::clear_has_loginreturn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Packet::clear_loginreturn() {
  if (loginreturn_ != NULL) loginreturn_->::PBMessage::LoginReturn::Clear();
  clear_has_loginreturn();
}
inline const ::PBMessage::LoginReturn& Packet::loginreturn() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.loginReturn)
  return loginreturn_ != NULL ? *loginreturn_
                         : *::PBMessage::LoginReturn::internal_default_instance();
}
inline ::PBMessage::LoginReturn* Packet::mutable_loginreturn() {
  set_has_loginreturn();
  if (loginreturn_ == NULL) {
    loginreturn_ = new ::PBMessage::LoginReturn;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.loginReturn)
  return loginreturn_;
}
inline ::PBMessage::LoginReturn* Packet::release_loginreturn() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.loginReturn)
  clear_has_loginreturn();
  ::PBMessage::LoginReturn* temp = loginreturn_;
  loginreturn_ = NULL;
  return temp;
}
inline void Packet::set_allocated_loginreturn(::PBMessage::LoginReturn* loginreturn) {
  delete loginreturn_;
  loginreturn_ = loginreturn;
  if (loginreturn) {
    set_has_loginreturn();
  } else {
    clear_has_loginreturn();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.loginReturn)
}

// optional .PBMessage.RegisterRequest registerRequest = 5;
inline bool Packet::has_registerrequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Packet::set_has_registerrequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Packet::clear_has_registerrequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Packet::clear_registerrequest() {
  if (registerrequest_ != NULL) registerrequest_->::PBMessage::RegisterRequest::Clear();
  clear_has_registerrequest();
}
inline const ::PBMessage::RegisterRequest& Packet::registerrequest() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.registerRequest)
  return registerrequest_ != NULL ? *registerrequest_
                         : *::PBMessage::RegisterRequest::internal_default_instance();
}
inline ::PBMessage::RegisterRequest* Packet::mutable_registerrequest() {
  set_has_registerrequest();
  if (registerrequest_ == NULL) {
    registerrequest_ = new ::PBMessage::RegisterRequest;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.registerRequest)
  return registerrequest_;
}
inline ::PBMessage::RegisterRequest* Packet::release_registerrequest() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.registerRequest)
  clear_has_registerrequest();
  ::PBMessage::RegisterRequest* temp = registerrequest_;
  registerrequest_ = NULL;
  return temp;
}
inline void Packet::set_allocated_registerrequest(::PBMessage::RegisterRequest* registerrequest) {
  delete registerrequest_;
  registerrequest_ = registerrequest;
  if (registerrequest) {
    set_has_registerrequest();
  } else {
    clear_has_registerrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.registerRequest)
}

// optional .PBMessage.RegisterReturn registerReturn = 6;
inline bool Packet::has_registerreturn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Packet::set_has_registerreturn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Packet::clear_has_registerreturn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Packet::clear_registerreturn() {
  if (registerreturn_ != NULL) registerreturn_->::PBMessage::RegisterReturn::Clear();
  clear_has_registerreturn();
}
inline const ::PBMessage::RegisterReturn& Packet::registerreturn() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.registerReturn)
  return registerreturn_ != NULL ? *registerreturn_
                         : *::PBMessage::RegisterReturn::internal_default_instance();
}
inline ::PBMessage::RegisterReturn* Packet::mutable_registerreturn() {
  set_has_registerreturn();
  if (registerreturn_ == NULL) {
    registerreturn_ = new ::PBMessage::RegisterReturn;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.registerReturn)
  return registerreturn_;
}
inline ::PBMessage::RegisterReturn* Packet::release_registerreturn() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.registerReturn)
  clear_has_registerreturn();
  ::PBMessage::RegisterReturn* temp = registerreturn_;
  registerreturn_ = NULL;
  return temp;
}
inline void Packet::set_allocated_registerreturn(::PBMessage::RegisterReturn* registerreturn) {
  delete registerreturn_;
  registerreturn_ = registerreturn;
  if (registerreturn) {
    set_has_registerreturn();
  } else {
    clear_has_registerreturn();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.registerReturn)
}

// optional .PBMessage.CreateRoleRequest createRoleRequest = 7;
inline bool Packet::has_createrolerequest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Packet::set_has_createrolerequest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Packet::clear_has_createrolerequest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Packet::clear_createrolerequest() {
  if (createrolerequest_ != NULL) createrolerequest_->::PBMessage::CreateRoleRequest::Clear();
  clear_has_createrolerequest();
}
inline const ::PBMessage::CreateRoleRequest& Packet::createrolerequest() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.createRoleRequest)
  return createrolerequest_ != NULL ? *createrolerequest_
                         : *::PBMessage::CreateRoleRequest::internal_default_instance();
}
inline ::PBMessage::CreateRoleRequest* Packet::mutable_createrolerequest() {
  set_has_createrolerequest();
  if (createrolerequest_ == NULL) {
    createrolerequest_ = new ::PBMessage::CreateRoleRequest;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.createRoleRequest)
  return createrolerequest_;
}
inline ::PBMessage::CreateRoleRequest* Packet::release_createrolerequest() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.createRoleRequest)
  clear_has_createrolerequest();
  ::PBMessage::CreateRoleRequest* temp = createrolerequest_;
  createrolerequest_ = NULL;
  return temp;
}
inline void Packet::set_allocated_createrolerequest(::PBMessage::CreateRoleRequest* createrolerequest) {
  delete createrolerequest_;
  createrolerequest_ = createrolerequest;
  if (createrolerequest) {
    set_has_createrolerequest();
  } else {
    clear_has_createrolerequest();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.createRoleRequest)
}

// optional .PBMessage.CreateRoleReturn createRoleReturn = 8;
inline bool Packet::has_createrolereturn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Packet::set_has_createrolereturn() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Packet::clear_has_createrolereturn() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Packet::clear_createrolereturn() {
  if (createrolereturn_ != NULL) createrolereturn_->::PBMessage::CreateRoleReturn::Clear();
  clear_has_createrolereturn();
}
inline const ::PBMessage::CreateRoleReturn& Packet::createrolereturn() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.createRoleReturn)
  return createrolereturn_ != NULL ? *createrolereturn_
                         : *::PBMessage::CreateRoleReturn::internal_default_instance();
}
inline ::PBMessage::CreateRoleReturn* Packet::mutable_createrolereturn() {
  set_has_createrolereturn();
  if (createrolereturn_ == NULL) {
    createrolereturn_ = new ::PBMessage::CreateRoleReturn;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.createRoleReturn)
  return createrolereturn_;
}
inline ::PBMessage::CreateRoleReturn* Packet::release_createrolereturn() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.createRoleReturn)
  clear_has_createrolereturn();
  ::PBMessage::CreateRoleReturn* temp = createrolereturn_;
  createrolereturn_ = NULL;
  return temp;
}
inline void Packet::set_allocated_createrolereturn(::PBMessage::CreateRoleReturn* createrolereturn) {
  delete createrolereturn_;
  createrolereturn_ = createrolereturn;
  if (createrolereturn) {
    set_has_createrolereturn();
  } else {
    clear_has_createrolereturn();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.createRoleReturn)
}

// optional .PBMessage.SelectRoleRequest selectRoleRequest = 9;
inline bool Packet::has_selectrolerequest() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Packet::set_has_selectrolerequest() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Packet::clear_has_selectrolerequest() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Packet::clear_selectrolerequest() {
  if (selectrolerequest_ != NULL) selectrolerequest_->::PBMessage::SelectRoleRequest::Clear();
  clear_has_selectrolerequest();
}
inline const ::PBMessage::SelectRoleRequest& Packet::selectrolerequest() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.selectRoleRequest)
  return selectrolerequest_ != NULL ? *selectrolerequest_
                         : *::PBMessage::SelectRoleRequest::internal_default_instance();
}
inline ::PBMessage::SelectRoleRequest* Packet::mutable_selectrolerequest() {
  set_has_selectrolerequest();
  if (selectrolerequest_ == NULL) {
    selectrolerequest_ = new ::PBMessage::SelectRoleRequest;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.selectRoleRequest)
  return selectrolerequest_;
}
inline ::PBMessage::SelectRoleRequest* Packet::release_selectrolerequest() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.selectRoleRequest)
  clear_has_selectrolerequest();
  ::PBMessage::SelectRoleRequest* temp = selectrolerequest_;
  selectrolerequest_ = NULL;
  return temp;
}
inline void Packet::set_allocated_selectrolerequest(::PBMessage::SelectRoleRequest* selectrolerequest) {
  delete selectrolerequest_;
  selectrolerequest_ = selectrolerequest;
  if (selectrolerequest) {
    set_has_selectrolerequest();
  } else {
    clear_has_selectrolerequest();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.selectRoleRequest)
}

// optional .PBMessage.SelectRoleReturn selectRoleReturn = 10;
inline bool Packet::has_selectrolereturn() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Packet::set_has_selectrolereturn() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Packet::clear_has_selectrolereturn() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Packet::clear_selectrolereturn() {
  if (selectrolereturn_ != NULL) selectrolereturn_->::PBMessage::SelectRoleReturn::Clear();
  clear_has_selectrolereturn();
}
inline const ::PBMessage::SelectRoleReturn& Packet::selectrolereturn() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.selectRoleReturn)
  return selectrolereturn_ != NULL ? *selectrolereturn_
                         : *::PBMessage::SelectRoleReturn::internal_default_instance();
}
inline ::PBMessage::SelectRoleReturn* Packet::mutable_selectrolereturn() {
  set_has_selectrolereturn();
  if (selectrolereturn_ == NULL) {
    selectrolereturn_ = new ::PBMessage::SelectRoleReturn;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.selectRoleReturn)
  return selectrolereturn_;
}
inline ::PBMessage::SelectRoleReturn* Packet::release_selectrolereturn() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.selectRoleReturn)
  clear_has_selectrolereturn();
  ::PBMessage::SelectRoleReturn* temp = selectrolereturn_;
  selectrolereturn_ = NULL;
  return temp;
}
inline void Packet::set_allocated_selectrolereturn(::PBMessage::SelectRoleReturn* selectrolereturn) {
  delete selectrolereturn_;
  selectrolereturn_ = selectrolereturn;
  if (selectrolereturn) {
    set_has_selectrolereturn();
  } else {
    clear_has_selectrolereturn();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.selectRoleReturn)
}

// optional .PBMessage.HallRequest hallRequest = 11;
inline bool Packet::has_hallrequest() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Packet::set_has_hallrequest() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Packet::clear_has_hallrequest() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Packet::clear_hallrequest() {
  if (hallrequest_ != NULL) hallrequest_->::PBMessage::HallRequest::Clear();
  clear_has_hallrequest();
}
inline const ::PBMessage::HallRequest& Packet::hallrequest() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.hallRequest)
  return hallrequest_ != NULL ? *hallrequest_
                         : *::PBMessage::HallRequest::internal_default_instance();
}
inline ::PBMessage::HallRequest* Packet::mutable_hallrequest() {
  set_has_hallrequest();
  if (hallrequest_ == NULL) {
    hallrequest_ = new ::PBMessage::HallRequest;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.hallRequest)
  return hallrequest_;
}
inline ::PBMessage::HallRequest* Packet::release_hallrequest() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.hallRequest)
  clear_has_hallrequest();
  ::PBMessage::HallRequest* temp = hallrequest_;
  hallrequest_ = NULL;
  return temp;
}
inline void Packet::set_allocated_hallrequest(::PBMessage::HallRequest* hallrequest) {
  delete hallrequest_;
  hallrequest_ = hallrequest;
  if (hallrequest) {
    set_has_hallrequest();
  } else {
    clear_has_hallrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.hallRequest)
}

// optional .PBMessage.HallReturn hallReturn = 12;
inline bool Packet::has_hallreturn() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Packet::set_has_hallreturn() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Packet::clear_has_hallreturn() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Packet::clear_hallreturn() {
  if (hallreturn_ != NULL) hallreturn_->::PBMessage::HallReturn::Clear();
  clear_has_hallreturn();
}
inline const ::PBMessage::HallReturn& Packet::hallreturn() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.hallReturn)
  return hallreturn_ != NULL ? *hallreturn_
                         : *::PBMessage::HallReturn::internal_default_instance();
}
inline ::PBMessage::HallReturn* Packet::mutable_hallreturn() {
  set_has_hallreturn();
  if (hallreturn_ == NULL) {
    hallreturn_ = new ::PBMessage::HallReturn;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.hallReturn)
  return hallreturn_;
}
inline ::PBMessage::HallReturn* Packet::release_hallreturn() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.hallReturn)
  clear_has_hallreturn();
  ::PBMessage::HallReturn* temp = hallreturn_;
  hallreturn_ = NULL;
  return temp;
}
inline void Packet::set_allocated_hallreturn(::PBMessage::HallReturn* hallreturn) {
  delete hallreturn_;
  hallreturn_ = hallreturn;
  if (hallreturn) {
    set_has_hallreturn();
  } else {
    clear_has_hallreturn();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.hallReturn)
}

// optional .PBMessage.GameMainRequest gameMainRequest = 13;
inline bool Packet::has_gamemainrequest() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Packet::set_has_gamemainrequest() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Packet::clear_has_gamemainrequest() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Packet::clear_gamemainrequest() {
  if (gamemainrequest_ != NULL) gamemainrequest_->::PBMessage::GameMainRequest::Clear();
  clear_has_gamemainrequest();
}
inline const ::PBMessage::GameMainRequest& Packet::gamemainrequest() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.gameMainRequest)
  return gamemainrequest_ != NULL ? *gamemainrequest_
                         : *::PBMessage::GameMainRequest::internal_default_instance();
}
inline ::PBMessage::GameMainRequest* Packet::mutable_gamemainrequest() {
  set_has_gamemainrequest();
  if (gamemainrequest_ == NULL) {
    gamemainrequest_ = new ::PBMessage::GameMainRequest;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.gameMainRequest)
  return gamemainrequest_;
}
inline ::PBMessage::GameMainRequest* Packet::release_gamemainrequest() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.gameMainRequest)
  clear_has_gamemainrequest();
  ::PBMessage::GameMainRequest* temp = gamemainrequest_;
  gamemainrequest_ = NULL;
  return temp;
}
inline void Packet::set_allocated_gamemainrequest(::PBMessage::GameMainRequest* gamemainrequest) {
  delete gamemainrequest_;
  gamemainrequest_ = gamemainrequest;
  if (gamemainrequest) {
    set_has_gamemainrequest();
  } else {
    clear_has_gamemainrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.gameMainRequest)
}

// optional .PBMessage.GameMainReturn gameMainReturn = 14;
inline bool Packet::has_gamemainreturn() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Packet::set_has_gamemainreturn() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Packet::clear_has_gamemainreturn() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Packet::clear_gamemainreturn() {
  if (gamemainreturn_ != NULL) gamemainreturn_->::PBMessage::GameMainReturn::Clear();
  clear_has_gamemainreturn();
}
inline const ::PBMessage::GameMainReturn& Packet::gamemainreturn() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.gameMainReturn)
  return gamemainreturn_ != NULL ? *gamemainreturn_
                         : *::PBMessage::GameMainReturn::internal_default_instance();
}
inline ::PBMessage::GameMainReturn* Packet::mutable_gamemainreturn() {
  set_has_gamemainreturn();
  if (gamemainreturn_ == NULL) {
    gamemainreturn_ = new ::PBMessage::GameMainReturn;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.gameMainReturn)
  return gamemainreturn_;
}
inline ::PBMessage::GameMainReturn* Packet::release_gamemainreturn() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.gameMainReturn)
  clear_has_gamemainreturn();
  ::PBMessage::GameMainReturn* temp = gamemainreturn_;
  gamemainreturn_ = NULL;
  return temp;
}
inline void Packet::set_allocated_gamemainreturn(::PBMessage::GameMainReturn* gamemainreturn) {
  delete gamemainreturn_;
  gamemainreturn_ = gamemainreturn;
  if (gamemainreturn) {
    set_has_gamemainreturn();
  } else {
    clear_has_gamemainreturn();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.gameMainReturn)
}

// optional .PBMessage.KeepAliveMsg keepAlive = 15;
inline bool Packet::has_keepalive() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Packet::set_has_keepalive() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Packet::clear_has_keepalive() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Packet::clear_keepalive() {
  if (keepalive_ != NULL) keepalive_->::PBMessage::KeepAliveMsg::Clear();
  clear_has_keepalive();
}
inline const ::PBMessage::KeepAliveMsg& Packet::keepalive() const {
  // @@protoc_insertion_point(field_get:PBMessage.Packet.keepAlive)
  return keepalive_ != NULL ? *keepalive_
                         : *::PBMessage::KeepAliveMsg::internal_default_instance();
}
inline ::PBMessage::KeepAliveMsg* Packet::mutable_keepalive() {
  set_has_keepalive();
  if (keepalive_ == NULL) {
    keepalive_ = new ::PBMessage::KeepAliveMsg;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.Packet.keepAlive)
  return keepalive_;
}
inline ::PBMessage::KeepAliveMsg* Packet::release_keepalive() {
  // @@protoc_insertion_point(field_release:PBMessage.Packet.keepAlive)
  clear_has_keepalive();
  ::PBMessage::KeepAliveMsg* temp = keepalive_;
  keepalive_ = NULL;
  return temp;
}
inline void Packet::set_allocated_keepalive(::PBMessage::KeepAliveMsg* keepalive) {
  delete keepalive_;
  keepalive_ = keepalive;
  if (keepalive) {
    set_has_keepalive();
  } else {
    clear_has_keepalive();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.Packet.keepAlive)
}

// -------------------------------------------------------------------

// UnPacket

// required .PBMessage.CurScene curScene = 1;
inline bool UnPacket::has_curscene() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UnPacket::set_has_curscene() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UnPacket::clear_has_curscene() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UnPacket::clear_curscene() {
  curscene_ = 0;
  clear_has_curscene();
}
inline ::PBMessage::CurScene UnPacket::curscene() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.curScene)
  return static_cast< ::PBMessage::CurScene >(curscene_);
}
inline void UnPacket::set_curscene(::PBMessage::CurScene value) {
  assert(::PBMessage::CurScene_IsValid(value));
  set_has_curscene();
  curscene_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.UnPacket.curScene)
}

// optional .PBMessage.MessageType msgType = 2;
inline bool UnPacket::has_msgtype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UnPacket::set_has_msgtype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UnPacket::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UnPacket::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::PBMessage::MessageType UnPacket::msgtype() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.msgType)
  return static_cast< ::PBMessage::MessageType >(msgtype_);
}
inline void UnPacket::set_msgtype(::PBMessage::MessageType value) {
  assert(::PBMessage::MessageType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:PBMessage.UnPacket.msgType)
}

// optional .PBMessage.LoginRequest loginRequest = 3;
inline bool UnPacket::has_loginrequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnPacket::set_has_loginrequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnPacket::clear_has_loginrequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnPacket::clear_loginrequest() {
  if (loginrequest_ != NULL) loginrequest_->::PBMessage::LoginRequest::Clear();
  clear_has_loginrequest();
}
inline const ::PBMessage::LoginRequest& UnPacket::loginrequest() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.loginRequest)
  return loginrequest_ != NULL ? *loginrequest_
                         : *::PBMessage::LoginRequest::internal_default_instance();
}
inline ::PBMessage::LoginRequest* UnPacket::mutable_loginrequest() {
  set_has_loginrequest();
  if (loginrequest_ == NULL) {
    loginrequest_ = new ::PBMessage::LoginRequest;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.loginRequest)
  return loginrequest_;
}
inline ::PBMessage::LoginRequest* UnPacket::release_loginrequest() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.loginRequest)
  clear_has_loginrequest();
  ::PBMessage::LoginRequest* temp = loginrequest_;
  loginrequest_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_loginrequest(::PBMessage::LoginRequest* loginrequest) {
  delete loginrequest_;
  loginrequest_ = loginrequest;
  if (loginrequest) {
    set_has_loginrequest();
  } else {
    clear_has_loginrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.loginRequest)
}

// optional .PBMessage.LoginReturn loginReturn = 4;
inline bool UnPacket::has_loginreturn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnPacket::set_has_loginreturn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnPacket::clear_has_loginreturn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnPacket::clear_loginreturn() {
  if (loginreturn_ != NULL) loginreturn_->::PBMessage::LoginReturn::Clear();
  clear_has_loginreturn();
}
inline const ::PBMessage::LoginReturn& UnPacket::loginreturn() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.loginReturn)
  return loginreturn_ != NULL ? *loginreturn_
                         : *::PBMessage::LoginReturn::internal_default_instance();
}
inline ::PBMessage::LoginReturn* UnPacket::mutable_loginreturn() {
  set_has_loginreturn();
  if (loginreturn_ == NULL) {
    loginreturn_ = new ::PBMessage::LoginReturn;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.loginReturn)
  return loginreturn_;
}
inline ::PBMessage::LoginReturn* UnPacket::release_loginreturn() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.loginReturn)
  clear_has_loginreturn();
  ::PBMessage::LoginReturn* temp = loginreturn_;
  loginreturn_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_loginreturn(::PBMessage::LoginReturn* loginreturn) {
  delete loginreturn_;
  loginreturn_ = loginreturn;
  if (loginreturn) {
    set_has_loginreturn();
  } else {
    clear_has_loginreturn();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.loginReturn)
}

// optional .PBMessage.RegisterRequest registerRequest = 5;
inline bool UnPacket::has_registerrequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnPacket::set_has_registerrequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnPacket::clear_has_registerrequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnPacket::clear_registerrequest() {
  if (registerrequest_ != NULL) registerrequest_->::PBMessage::RegisterRequest::Clear();
  clear_has_registerrequest();
}
inline const ::PBMessage::RegisterRequest& UnPacket::registerrequest() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.registerRequest)
  return registerrequest_ != NULL ? *registerrequest_
                         : *::PBMessage::RegisterRequest::internal_default_instance();
}
inline ::PBMessage::RegisterRequest* UnPacket::mutable_registerrequest() {
  set_has_registerrequest();
  if (registerrequest_ == NULL) {
    registerrequest_ = new ::PBMessage::RegisterRequest;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.registerRequest)
  return registerrequest_;
}
inline ::PBMessage::RegisterRequest* UnPacket::release_registerrequest() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.registerRequest)
  clear_has_registerrequest();
  ::PBMessage::RegisterRequest* temp = registerrequest_;
  registerrequest_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_registerrequest(::PBMessage::RegisterRequest* registerrequest) {
  delete registerrequest_;
  registerrequest_ = registerrequest;
  if (registerrequest) {
    set_has_registerrequest();
  } else {
    clear_has_registerrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.registerRequest)
}

// optional .PBMessage.RegisterReturn registerReturn = 6;
inline bool UnPacket::has_registerreturn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnPacket::set_has_registerreturn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnPacket::clear_has_registerreturn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnPacket::clear_registerreturn() {
  if (registerreturn_ != NULL) registerreturn_->::PBMessage::RegisterReturn::Clear();
  clear_has_registerreturn();
}
inline const ::PBMessage::RegisterReturn& UnPacket::registerreturn() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.registerReturn)
  return registerreturn_ != NULL ? *registerreturn_
                         : *::PBMessage::RegisterReturn::internal_default_instance();
}
inline ::PBMessage::RegisterReturn* UnPacket::mutable_registerreturn() {
  set_has_registerreturn();
  if (registerreturn_ == NULL) {
    registerreturn_ = new ::PBMessage::RegisterReturn;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.registerReturn)
  return registerreturn_;
}
inline ::PBMessage::RegisterReturn* UnPacket::release_registerreturn() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.registerReturn)
  clear_has_registerreturn();
  ::PBMessage::RegisterReturn* temp = registerreturn_;
  registerreturn_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_registerreturn(::PBMessage::RegisterReturn* registerreturn) {
  delete registerreturn_;
  registerreturn_ = registerreturn;
  if (registerreturn) {
    set_has_registerreturn();
  } else {
    clear_has_registerreturn();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.registerReturn)
}

// optional .PBMessage.CreateRoleRequest createRoleRequest = 7;
inline bool UnPacket::has_createrolerequest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UnPacket::set_has_createrolerequest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UnPacket::clear_has_createrolerequest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UnPacket::clear_createrolerequest() {
  if (createrolerequest_ != NULL) createrolerequest_->::PBMessage::CreateRoleRequest::Clear();
  clear_has_createrolerequest();
}
inline const ::PBMessage::CreateRoleRequest& UnPacket::createrolerequest() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.createRoleRequest)
  return createrolerequest_ != NULL ? *createrolerequest_
                         : *::PBMessage::CreateRoleRequest::internal_default_instance();
}
inline ::PBMessage::CreateRoleRequest* UnPacket::mutable_createrolerequest() {
  set_has_createrolerequest();
  if (createrolerequest_ == NULL) {
    createrolerequest_ = new ::PBMessage::CreateRoleRequest;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.createRoleRequest)
  return createrolerequest_;
}
inline ::PBMessage::CreateRoleRequest* UnPacket::release_createrolerequest() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.createRoleRequest)
  clear_has_createrolerequest();
  ::PBMessage::CreateRoleRequest* temp = createrolerequest_;
  createrolerequest_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_createrolerequest(::PBMessage::CreateRoleRequest* createrolerequest) {
  delete createrolerequest_;
  createrolerequest_ = createrolerequest;
  if (createrolerequest) {
    set_has_createrolerequest();
  } else {
    clear_has_createrolerequest();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.createRoleRequest)
}

// optional .PBMessage.CreateRoleReturn createRoleReturn = 8;
inline bool UnPacket::has_createrolereturn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UnPacket::set_has_createrolereturn() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UnPacket::clear_has_createrolereturn() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UnPacket::clear_createrolereturn() {
  if (createrolereturn_ != NULL) createrolereturn_->::PBMessage::CreateRoleReturn::Clear();
  clear_has_createrolereturn();
}
inline const ::PBMessage::CreateRoleReturn& UnPacket::createrolereturn() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.createRoleReturn)
  return createrolereturn_ != NULL ? *createrolereturn_
                         : *::PBMessage::CreateRoleReturn::internal_default_instance();
}
inline ::PBMessage::CreateRoleReturn* UnPacket::mutable_createrolereturn() {
  set_has_createrolereturn();
  if (createrolereturn_ == NULL) {
    createrolereturn_ = new ::PBMessage::CreateRoleReturn;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.createRoleReturn)
  return createrolereturn_;
}
inline ::PBMessage::CreateRoleReturn* UnPacket::release_createrolereturn() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.createRoleReturn)
  clear_has_createrolereturn();
  ::PBMessage::CreateRoleReturn* temp = createrolereturn_;
  createrolereturn_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_createrolereturn(::PBMessage::CreateRoleReturn* createrolereturn) {
  delete createrolereturn_;
  createrolereturn_ = createrolereturn;
  if (createrolereturn) {
    set_has_createrolereturn();
  } else {
    clear_has_createrolereturn();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.createRoleReturn)
}

// optional .PBMessage.SelectRoleRequest selectRoleRequest = 9;
inline bool UnPacket::has_selectrolerequest() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UnPacket::set_has_selectrolerequest() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UnPacket::clear_has_selectrolerequest() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UnPacket::clear_selectrolerequest() {
  if (selectrolerequest_ != NULL) selectrolerequest_->::PBMessage::SelectRoleRequest::Clear();
  clear_has_selectrolerequest();
}
inline const ::PBMessage::SelectRoleRequest& UnPacket::selectrolerequest() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.selectRoleRequest)
  return selectrolerequest_ != NULL ? *selectrolerequest_
                         : *::PBMessage::SelectRoleRequest::internal_default_instance();
}
inline ::PBMessage::SelectRoleRequest* UnPacket::mutable_selectrolerequest() {
  set_has_selectrolerequest();
  if (selectrolerequest_ == NULL) {
    selectrolerequest_ = new ::PBMessage::SelectRoleRequest;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.selectRoleRequest)
  return selectrolerequest_;
}
inline ::PBMessage::SelectRoleRequest* UnPacket::release_selectrolerequest() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.selectRoleRequest)
  clear_has_selectrolerequest();
  ::PBMessage::SelectRoleRequest* temp = selectrolerequest_;
  selectrolerequest_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_selectrolerequest(::PBMessage::SelectRoleRequest* selectrolerequest) {
  delete selectrolerequest_;
  selectrolerequest_ = selectrolerequest;
  if (selectrolerequest) {
    set_has_selectrolerequest();
  } else {
    clear_has_selectrolerequest();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.selectRoleRequest)
}

// optional .PBMessage.SelectRoleReturn selectRoleReturn = 10;
inline bool UnPacket::has_selectrolereturn() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UnPacket::set_has_selectrolereturn() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UnPacket::clear_has_selectrolereturn() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UnPacket::clear_selectrolereturn() {
  if (selectrolereturn_ != NULL) selectrolereturn_->::PBMessage::SelectRoleReturn::Clear();
  clear_has_selectrolereturn();
}
inline const ::PBMessage::SelectRoleReturn& UnPacket::selectrolereturn() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.selectRoleReturn)
  return selectrolereturn_ != NULL ? *selectrolereturn_
                         : *::PBMessage::SelectRoleReturn::internal_default_instance();
}
inline ::PBMessage::SelectRoleReturn* UnPacket::mutable_selectrolereturn() {
  set_has_selectrolereturn();
  if (selectrolereturn_ == NULL) {
    selectrolereturn_ = new ::PBMessage::SelectRoleReturn;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.selectRoleReturn)
  return selectrolereturn_;
}
inline ::PBMessage::SelectRoleReturn* UnPacket::release_selectrolereturn() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.selectRoleReturn)
  clear_has_selectrolereturn();
  ::PBMessage::SelectRoleReturn* temp = selectrolereturn_;
  selectrolereturn_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_selectrolereturn(::PBMessage::SelectRoleReturn* selectrolereturn) {
  delete selectrolereturn_;
  selectrolereturn_ = selectrolereturn;
  if (selectrolereturn) {
    set_has_selectrolereturn();
  } else {
    clear_has_selectrolereturn();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.selectRoleReturn)
}

// optional .PBMessage.HallRequest hallRequest = 11;
inline bool UnPacket::has_hallrequest() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UnPacket::set_has_hallrequest() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UnPacket::clear_has_hallrequest() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UnPacket::clear_hallrequest() {
  if (hallrequest_ != NULL) hallrequest_->::PBMessage::HallRequest::Clear();
  clear_has_hallrequest();
}
inline const ::PBMessage::HallRequest& UnPacket::hallrequest() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.hallRequest)
  return hallrequest_ != NULL ? *hallrequest_
                         : *::PBMessage::HallRequest::internal_default_instance();
}
inline ::PBMessage::HallRequest* UnPacket::mutable_hallrequest() {
  set_has_hallrequest();
  if (hallrequest_ == NULL) {
    hallrequest_ = new ::PBMessage::HallRequest;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.hallRequest)
  return hallrequest_;
}
inline ::PBMessage::HallRequest* UnPacket::release_hallrequest() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.hallRequest)
  clear_has_hallrequest();
  ::PBMessage::HallRequest* temp = hallrequest_;
  hallrequest_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_hallrequest(::PBMessage::HallRequest* hallrequest) {
  delete hallrequest_;
  hallrequest_ = hallrequest;
  if (hallrequest) {
    set_has_hallrequest();
  } else {
    clear_has_hallrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.hallRequest)
}

// optional .PBMessage.HallReturn hallReturn = 12;
inline bool UnPacket::has_hallreturn() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UnPacket::set_has_hallreturn() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UnPacket::clear_has_hallreturn() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UnPacket::clear_hallreturn() {
  if (hallreturn_ != NULL) hallreturn_->::PBMessage::HallReturn::Clear();
  clear_has_hallreturn();
}
inline const ::PBMessage::HallReturn& UnPacket::hallreturn() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.hallReturn)
  return hallreturn_ != NULL ? *hallreturn_
                         : *::PBMessage::HallReturn::internal_default_instance();
}
inline ::PBMessage::HallReturn* UnPacket::mutable_hallreturn() {
  set_has_hallreturn();
  if (hallreturn_ == NULL) {
    hallreturn_ = new ::PBMessage::HallReturn;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.hallReturn)
  return hallreturn_;
}
inline ::PBMessage::HallReturn* UnPacket::release_hallreturn() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.hallReturn)
  clear_has_hallreturn();
  ::PBMessage::HallReturn* temp = hallreturn_;
  hallreturn_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_hallreturn(::PBMessage::HallReturn* hallreturn) {
  delete hallreturn_;
  hallreturn_ = hallreturn;
  if (hallreturn) {
    set_has_hallreturn();
  } else {
    clear_has_hallreturn();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.hallReturn)
}

// optional .PBMessage.GameMainRequest gameMainRequest = 13;
inline bool UnPacket::has_gamemainrequest() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UnPacket::set_has_gamemainrequest() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UnPacket::clear_has_gamemainrequest() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UnPacket::clear_gamemainrequest() {
  if (gamemainrequest_ != NULL) gamemainrequest_->::PBMessage::GameMainRequest::Clear();
  clear_has_gamemainrequest();
}
inline const ::PBMessage::GameMainRequest& UnPacket::gamemainrequest() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.gameMainRequest)
  return gamemainrequest_ != NULL ? *gamemainrequest_
                         : *::PBMessage::GameMainRequest::internal_default_instance();
}
inline ::PBMessage::GameMainRequest* UnPacket::mutable_gamemainrequest() {
  set_has_gamemainrequest();
  if (gamemainrequest_ == NULL) {
    gamemainrequest_ = new ::PBMessage::GameMainRequest;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.gameMainRequest)
  return gamemainrequest_;
}
inline ::PBMessage::GameMainRequest* UnPacket::release_gamemainrequest() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.gameMainRequest)
  clear_has_gamemainrequest();
  ::PBMessage::GameMainRequest* temp = gamemainrequest_;
  gamemainrequest_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_gamemainrequest(::PBMessage::GameMainRequest* gamemainrequest) {
  delete gamemainrequest_;
  gamemainrequest_ = gamemainrequest;
  if (gamemainrequest) {
    set_has_gamemainrequest();
  } else {
    clear_has_gamemainrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.gameMainRequest)
}

// optional .PBMessage.GameMainReturn gameMainReturn = 14;
inline bool UnPacket::has_gamemainreturn() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UnPacket::set_has_gamemainreturn() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UnPacket::clear_has_gamemainreturn() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UnPacket::clear_gamemainreturn() {
  if (gamemainreturn_ != NULL) gamemainreturn_->::PBMessage::GameMainReturn::Clear();
  clear_has_gamemainreturn();
}
inline const ::PBMessage::GameMainReturn& UnPacket::gamemainreturn() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.gameMainReturn)
  return gamemainreturn_ != NULL ? *gamemainreturn_
                         : *::PBMessage::GameMainReturn::internal_default_instance();
}
inline ::PBMessage::GameMainReturn* UnPacket::mutable_gamemainreturn() {
  set_has_gamemainreturn();
  if (gamemainreturn_ == NULL) {
    gamemainreturn_ = new ::PBMessage::GameMainReturn;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.gameMainReturn)
  return gamemainreturn_;
}
inline ::PBMessage::GameMainReturn* UnPacket::release_gamemainreturn() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.gameMainReturn)
  clear_has_gamemainreturn();
  ::PBMessage::GameMainReturn* temp = gamemainreturn_;
  gamemainreturn_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_gamemainreturn(::PBMessage::GameMainReturn* gamemainreturn) {
  delete gamemainreturn_;
  gamemainreturn_ = gamemainreturn;
  if (gamemainreturn) {
    set_has_gamemainreturn();
  } else {
    clear_has_gamemainreturn();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.gameMainReturn)
}

// optional .PBMessage.KeepAliveMsg keepAlive = 15;
inline bool UnPacket::has_keepalive() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UnPacket::set_has_keepalive() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UnPacket::clear_has_keepalive() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UnPacket::clear_keepalive() {
  if (keepalive_ != NULL) keepalive_->::PBMessage::KeepAliveMsg::Clear();
  clear_has_keepalive();
}
inline const ::PBMessage::KeepAliveMsg& UnPacket::keepalive() const {
  // @@protoc_insertion_point(field_get:PBMessage.UnPacket.keepAlive)
  return keepalive_ != NULL ? *keepalive_
                         : *::PBMessage::KeepAliveMsg::internal_default_instance();
}
inline ::PBMessage::KeepAliveMsg* UnPacket::mutable_keepalive() {
  set_has_keepalive();
  if (keepalive_ == NULL) {
    keepalive_ = new ::PBMessage::KeepAliveMsg;
  }
  // @@protoc_insertion_point(field_mutable:PBMessage.UnPacket.keepAlive)
  return keepalive_;
}
inline ::PBMessage::KeepAliveMsg* UnPacket::release_keepalive() {
  // @@protoc_insertion_point(field_release:PBMessage.UnPacket.keepAlive)
  clear_has_keepalive();
  ::PBMessage::KeepAliveMsg* temp = keepalive_;
  keepalive_ = NULL;
  return temp;
}
inline void UnPacket::set_allocated_keepalive(::PBMessage::KeepAliveMsg* keepalive) {
  delete keepalive_;
  keepalive_ = keepalive;
  if (keepalive) {
    set_has_keepalive();
  } else {
    clear_has_keepalive();
  }
  // @@protoc_insertion_point(field_set_allocated:PBMessage.UnPacket.keepAlive)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace PBMessage

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::PBMessage::CommandID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMessage::CommandID>() {
  return ::PBMessage::CommandID_descriptor();
}
template <> struct is_proto_enum< ::PBMessage::CurScene> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMessage::CurScene>() {
  return ::PBMessage::CurScene_descriptor();
}
template <> struct is_proto_enum< ::PBMessage::MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMessage::MessageType>() {
  return ::PBMessage::MessageType_descriptor();
}
template <> struct is_proto_enum< ::PBMessage::LoginReturnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMessage::LoginReturnType>() {
  return ::PBMessage::LoginReturnType_descriptor();
}
template <> struct is_proto_enum< ::PBMessage::RegisterReturnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMessage::RegisterReturnType>() {
  return ::PBMessage::RegisterReturnType_descriptor();
}
template <> struct is_proto_enum< ::PBMessage::CreateRoleReturnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMessage::CreateRoleReturnType>() {
  return ::PBMessage::CreateRoleReturnType_descriptor();
}
template <> struct is_proto_enum< ::PBMessage::HallMsgType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMessage::HallMsgType>() {
  return ::PBMessage::HallMsgType_descriptor();
}
template <> struct is_proto_enum< ::PBMessage::GameMainMsgType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBMessage::GameMainMsgType>() {
  return ::PBMessage::GameMainMsgType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_command_2etxt__INCLUDED
